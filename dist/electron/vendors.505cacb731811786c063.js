(this["webpackJsonp"] = this["webpackJsonp"] || []).push([
  [102],
  {
    1207: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      t.default = [
        { code: "BTC", name: "Bitcoin", char: "Ƀ" },
        {
          code: "USD",
          name: "United States dollar",
          char: "&#36;",
          default: 200,
        },
        { code: "EUR", name: "Euro", char: "&#8364;", default: 200 },
        { code: "GBP", name: "British pound", char: "&#163;", default: 200 },
        { code: "AUD", name: "Australian dollar", char: "&#36;" },
        { code: "BRL", name: "Brazilian real", char: "&#82;&#36;" },
        { code: "CAD", name: "Canadian dollar", char: "&#36;" },
        { code: "CHF", name: "Swiss franc", char: "&#67;&#72;&#70;" },
        { code: "CLP", name: "Chilean peso", char: "&#36;" },
        { code: "CNY", name: "Chinese yuan", char: "&#165;" },
        { code: "CZK", name: "Czech koruna", char: "&#75;&#269;" },
        { code: "DKK", name: "Danish krone", char: "&#107;&#114;" },
        { code: "HKD", name: "Hong Kong dollar", char: "&#36;" },
        { code: "HUF", name: "Hungrian forint", char: "&#70;&#116;" },
        { code: "IDR", name: "Indonesian rupiah", char: "&#82;&#112;" },
        { code: "ILS", name: "Israel new shekel", char: "&#8362;" },
        { code: "INR", name: "Indian rupee", char: "&#8377;" },
        { code: "JPY", name: "Japanese yen", char: "&#165;" },
        { code: "KRW", name: "South Korean won", char: "&#65510;" },
        { code: "MXN", name: "Mexican peso", char: "&#36;" },
        { code: "MYR", name: "Malaysian ringgit", char: "&#82;&#77;" },
        { code: "NOK", name: "Norway krone", char: "&#107;&#114;" },
        { code: "NZD", name: "New Zealand dollar", char: "&#36;" },
        { code: "PHP", name: "Philippine peso", char: "&#8369;" },
        { code: "PKR", name: "Pakistani ruppie", char: "&#8360;" },
        { code: "PLN", name: "Polish zloty", char: "&#122;&#322;" },
        { code: "RUB", name: "Russian ruble", char: "&#8381;" },
        { code: "SEK", name: "Swedish krona", char: "&#107;&#114;" },
        { code: "SGD", name: "Singapore dollar", char: "&#36;" },
        { code: "THB", name: "Thai bat", char: "&#3647;" },
        { code: "TRY", name: "Turkish lira", char: "₺" },
        { code: "TWD", name: "New Taiwan dollar", char: "&#78;&#84;&#36;" },
        { code: "ZAR", name: "South African rand", char: "&#82;" },
        { code: "AED", name: "United Arab Emirates Dirham", char: "&#82;" },
        { code: "UAH", name: "Ukrainian hryvnia", char: "&#8372;" },
        { code: "VND", name: "Vietnamese Dong", char: "&#x20ab;" },
        { code: "KZT", name: "Kazakhstani tenge", char: "&#8376;" },
        { code: "DOP", name: "Dominican peso", char: "&#8369;" },
        { code: "PEN", name: "Peruvian sol", char: "&#x53;&#x2f;&#x2e;" },
        { code: "MDL", name: "Moldovan leu", char: "L" },
        { code: "QAR", name: "Qatari riyal", char: "QR" },
        { code: "GEL", name: "Georgian lari", char: "ლ;" },
        { code: "UYU", name: "Uruguayan peso", char: "$U" },
        { code: "CRC", name: "Costa Rican colón", char: "₡" },
        { code: "NAD", name: "Namibian dollar", char: "N$" },
        { code: "AZN", name: "Azerbaijani manat", char: "₼" },
        { code: "NGN", name: "Nigerian naira", char: "₦" },
        { code: "BGN", name: "Bulgarian lev", char: "lv." },
        { code: "MAD", name: "Moroccan dirham", char: "DH" },
        { code: "RON", name: "Romanian leu", char: "L" },
        { code: "ARS", name: "Argentine peso", char: "Arg$" },
        { code: "ALL", name: "Albanian Lek", char: "Lek" },
        { code: "BDT", name: "Bangladeshi taka", char: "৳" },
        { code: "EGP", name: "Egyptian pound", char: "£E" },
        { code: "HRK", name: "Croatian kuna", char: "kn" },
        { code: "JOD", name: "Jordanian dinar", char: "JD" },
        { code: "KWD", name: "Kuwaiti dinar", char: "KD" },
        { code: "COP", name: "Colombian peso", char: "$" },
        { code: "SAR", name: "Saudi riyal", char: "SR" },
        { code: "BHD", name: "Bahraini dinar", char: "BD" },
        { code: "IQD", name: "Iraqi dinar", char: "ID;" },
        { code: "OMR", name: "Omani rial", char: "R.O;" },
        { code: "LKR", name: "Sri Lankan rupee", char: "௹;" },
        { code: "BOB", name: "Bolivian boliviano", char: "Bs;" },
        { code: "ANG", name: "Netherlands Antillean guilder", char: "NAƒ" },
        { code: "BBD", name: "Barbados dollar ", char: "BBD$" },
        { code: "BMD", name: "Bermudian dollar", char: "$" },
        { code: "BND", name: "Brunei dollar", char: "B$" },
        { code: "BWP", name: "Botswana pula", char: "P" },
        { code: "DJF", name: "Djiboutian franc", char: "Fdj" },
        { code: "GHS", name: "Ghanaian cedi", char: "₵" },
        { code: "GTQ", name: "Guatemalan quetzal", char: "Q" },
        { code: "TZS", name: "Tanzanian shilling", char: "TSh" },
        { code: "UGX", name: "Ugandan shilling", char: "USh" },
        { code: "XOF", name: "CFA franc", char: "F.CFA;" },
        { code: "KGS", name: "Kyrgyzstani som", char: "с" },
        { code: "MZN", name: "Mozambican metical", char: "MTn" },
        {
          code: "BAM",
          name: "Bosnia and Herzegovina convertible mark",
          char: "KM",
        },
        { code: "MNT", name: "Mongolian tögrög", char: "₮" },
        { code: "AMD", name: "Armenian dram", char: "֏" },
        { code: "KHR", name: "Cambodian riel", char: "៛" },
        { code: "KYD", name: "Cayman Islands dollar", char: "CI$" },
        { code: "LBP", name: "Lebanese pound", char: "LL" },
        { code: "PAB", name: "Panamanian balboa", char: "B/." },
        { code: "PGK", name: "Papua New Guinean kina", char: "K" },
        { code: "PYG", name: "Paraguayan guaraní", char: "₲" },
        { code: "KES", name: "Kenyan shilling", char: "KSh" },
        { code: "RSD", name: "Serbian dinar", char: "DIN" },
        { code: "SOS", name: "Somali shilling", char: "Sh.So." },
        { code: "MOP", name: "Macanese pataca", char: "$" },
        { code: "MUR", name: "Mauritian rupee", char: "Re/Rs" },
        { code: "ISK", name: "Icelandic króna", char: "kr" },
        { code: "JMD", name: "Jamaican dollar", char: "$" },
        { code: "MKD", name: "Macedonian denar", char: "den" },
      ];
    },
    124: function (e, t, a) {
      "use strict";
      (function (e) {
        var n = a(0);
        (Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = t.Wallets = t.ALIASES = void 0));
        var r = n(a(1212)),
          i = a(4),
          s = n(a(402)),
          o = L(a(103)),
          l = n(a(8)),
          c = a(74),
          d = n(a(230)),
          u = n(a(21)),
          h = n(a(258)),
          f = n(a(81)),
          m = n(a(28)),
          p = n(a(37)),
          y = n(a(1243)),
          g = n(a(80)),
          w = n(a(1270)),
          T = a(35),
          v = n(a(26)),
          b = a(675),
          C = a(85),
          k = a(1989),
          E = L(a(676)),
          A = a(403),
          P = a(340),
          _ = a(331),
          S = a(854);
        function L(e, t) {
          if ("function" == typeof WeakMap)
            var a = new WeakMap(),
              n = new WeakMap();
          return (L = function (e, t) {
            if (!t && e && e.__esModule) return e;
            var r,
              i,
              s = { __proto__: null, default: e };
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return s;
            if ((r = t ? n : a)) {
              if (r.has(e)) return r.get(e);
              r.set(e, s);
            }
            for (const a in e)
              "default" !== a &&
                {}.hasOwnProperty.call(e, a) &&
                ((i =
                  (r = Object.defineProperty) &&
                  Object.getOwnPropertyDescriptor(e, a)) &&
                (i.get || i.set)
                  ? r(s, a, i)
                  : (s[a] = e[a]));
            return s;
          })(e, t);
        }
        function N(e, t) {
          (x(e, t), t.add(e));
        }
        function O(e, t, a) {
          (x(e, t), t.set(e, a));
        }
        function x(e, t) {
          if (t.has(e))
            throw new TypeError(
              "Cannot initialize the same private elements twice on an object",
            );
        }
        function I(e, t) {
          return e.get(D(e, t));
        }
        function R(e, t, a) {
          return (e.set(D(e, t), a), a);
        }
        function D(e, t, a) {
          if ("function" == typeof e ? e === t : e.has(t))
            return arguments.length < 3 ? t : a;
          throw new TypeError("Private element is not present on this object");
        }
        const M = 5,
          F = 50,
          U = 6e4,
          B = 3e5,
          G = (t.ALIASES = { MAIN: "atomic", NEW: "new" });
        var W = new WeakMap(),
          K = new WeakMap(),
          j = new WeakMap(),
          q = new WeakMap(),
          V = new WeakMap(),
          $ = new WeakSet();
        class Wallets {
          constructor() {
            (N(this, $),
              O(this, W, void 0),
              O(this, K, void 0),
              O(this, j, null),
              O(this, q, null),
              O(this, V, void 0),
              R(K, this, {
                walletsCollection: { [G.MAIN]: new Map(), [G.NEW]: new Map() },
              }),
              (this.logger = m.default),
              (this.socket = null),
              (this.autoUpdateBalances = !0),
              (this.autoUpdateTransactions = !0),
              (this.autoUpdateCoinsDataCounter = null),
              (this.autoUpdateBalancesCounter = null),
              (this.autoUpdateTransactionsCounter = null),
              (this.disabledSockets = !1),
              (this.updateProcessFlag = !1),
              (this.balanceNotifier = new k.BalanceNotifier(v.default, [])));
          }
          [Symbol.iterator](e) {
            return (void 0 === e && (e = G.MAIN), D($, this, H).call(this, e));
          }
          list(e) {
            return (
              void 0 === e && (e = G.MAIN),
              Array.from(D($, this, H).call(this, e))
            );
          }
          getCoins(e) {
            return (
              void 0 === e && (e = G.MAIN),
              this.list(e).filter((e) => e instanceof d.default)
            );
          }
          getTokens(e) {
            return (
              void 0 === e && (e = G.MAIN),
              this.list(e).filter((e) => e instanceof u.default)
            );
          }
          filter(e, t) {
            return (void 0 === t && (t = G.MAIN), this.list(t).filter(e));
          }
          forEach(e, t) {
            return this.list(t).forEach(e);
          }
          getWalletsWithCustomTokens(e) {
            return (
              void 0 === e && (e = G.MAIN),
              this.list(e).filter(
                (e) => e instanceof d.default && e.isCustomTokenSupported,
              )
            );
          }
          updateBalanceTrackingConfig() {
            l.default
              .getLocal(c.ConfigKey.BalanceTracking)
              .then((e) => {
                this.balanceNotifier.config = e;
              })
              .then(() => l.default.get(c.ConfigKey.BalanceTracking, !0))
              .then((e) => {
                this.balanceNotifier.config = e;
              })
              .catch(() => {
                console.warn("Could not load balance tracking config.");
              });
          }
          async preloadActiveCoins() {
            const e = new w.default(
              {
                walletConfigs: await l.default.getLocal(c.ConfigKey.WalletsFee),
                params: { atomicId: this.hash },
              },
              async (e) => {},
            );
            await Promise.all([
              e.preloadCoinClasses(),
              D($, this, Q).call(this),
            ]);
          }
          async initialize(e) {
            var t;
            return (
              R(
                W,
                this,
                null !== (t = I(W, this)) && void 0 !== t
                  ? t
                  : (async () => {
                      (Object.values(I(K, this).walletsCollection).forEach(
                        (e) => e.clear(),
                      ),
                        (this.walletsConfig = await l.default.getLocal(
                          c.ConfigKey.WalletsFee,
                        )),
                        l.default.get(c.ConfigKey.WalletsFee, !0).catch(),
                        v.default.once(T.CONFIGS.UPDATED, (e) => {
                          let { id: t, config: a } = e;
                          t === c.ConfigKey.WalletsFee &&
                            (0, S.isDifferent)(this.walletsConfig, a) &&
                            (this.walletsConfig = a);
                        }));
                      const t = await i.db.customWallets.toArray(),
                        a = t.map((e) => {
                          let { walletType: t, ...a } = e;
                          return { className: t + "Coin", walletType: t, ...a };
                        }),
                        n = new w.default(
                          {
                            walletConfigs: [...a, ...this.walletsConfig],
                            params: { atomicId: this.hash },
                          },
                          (e) => {
                            try {
                              D($, this, Y).call(this, e);
                            } catch (t) {
                              console.error(t);
                            }
                          },
                        ),
                        r = this.list();
                      try {
                        (await n.installCoins(), await n.installTokens());
                      } catch (s) {
                        (m.default.error({ instance: this, error: s }),
                          await Promise.allSettled(
                            r.map((e) => D($, this, Y).call(this, e)),
                          ));
                      } finally {
                        (D($, this, Z).call(this, this.walletsConfig, e),
                          D($, this, X).call(this, e),
                          v.default.on(T.CONFIGS.UPDATED, (t) => {
                            let { id: a, config: n } = t;
                            a === c.ConfigKey.WalletsFee &&
                              (0, S.isDifferent)(this.walletsConfig, n) &&
                              (D($, this, Z).call(this, n, e),
                              (this.walletsConfig = n));
                          }));
                      }
                      (this.list().forEach((e) => {
                        try {
                          const { createTransaction: t, sendTransaction: a } =
                            (0, _.createSendTransactionStatTracker)(this, e);
                          (t && (e.createTransaction = t),
                            a && (e.sendTransaction = a));
                        } catch (s) {
                          console.error(s);
                        }
                      }),
                        await this.initTransactionsCache(),
                        v.default.emit(T.WALLETS.WALLET_READY));
                    })(),
              ),
              I(W, this)
            );
          }
          async createWallets(e) {
            const t = await D($, this, z).call(this, { password: e });
            (o.default.reset(),
              o.default.setAllActivitiesAsNegative(
                (await l.default.getLocal(c.ConfigKey.WalletsFee)).map((e) => {
                  let { id: t, className: a } = e;
                  return (
                    t ||
                      console.warn(
                        a + " does not have id in local wallets_fee file",
                      ),
                    t
                  );
                }),
              ),
              await this.initialize(t, G.MAIN));
            const a = await D($, this, te).call(this, t);
            return (
              await D($, this, oe).call(this, a),
              i.requestQueueState.setAsCompleted(i.REQUEST_TYPE.WALLETS_LOADED),
              t.phrase
            );
          }
          async restoreWallets(e, t) {
            const a = await D($, this, z).call(this, {
              password: t,
              phrase: e,
            });
            (o.default.reset(),
              await h.default.reset(),
              await this.initialize(a, G.MAIN));
            const n = await D($, this, te).call(this, a);
            (await D($, this, oe).call(this, n),
              i.requestQueueState.setAsCompleted(i.REQUEST_TYPE.WALLETS_LOADED),
              this.getTransactions());
          }
          async loadWallets(e, t) {
            const a = await I(V, this).getByPassword(E.MNEMONIC_KEY, t),
              n = await D($, this, z).call(this, { phrase: a, password: t }),
              r = e.filter((e) => e.privateKey);
            (await D($, this, ae).call(this, r, n),
              i.requestQueueState.setAsCompleted(
                i.REQUEST_TYPE.WALLETS_LOADED,
              ));
          }
          isWalletActive(e) {
            return o.default.isActive(e);
          }
          setActivityChecked(e, t, a) {
            o.default.trackActivity(e, t, a);
          }
          setAutoUpdateBalances(e) {
            (void 0 === e && (e = !0), (this.autoUpdateBalances = e));
          }
          setAutoUpdateTransactions(e) {
            (void 0 === e && (e = !0), (this.autoUpdateTransactions = e));
          }
          async validateMnemonic(e) {
            return (await D($, this, Q).call(this)).isValid(e);
          }
          initUpdateNft(e) {
            let { isSpamNftsEnabled: t = !1 } = void 0 === e ? {} : e;
            return (
              I(q, this) ||
                R(
                  q,
                  this,
                  D($, this, re)
                    .call(this, t)
                    .finally(() => {
                      R(q, this, null);
                    }),
                ),
              I(q, this)
            );
          }
          stopUpdateNft() {}
          async fetchTransactions(e, t) {
            try {
              if (!e.address) throw new Error(e.id + " address is not set");
              return e.getTransactions({ address: e.address, pageNum: t });
            } catch (a) {
              return [];
            }
          }
          async initUpdateTransactions() {
            if (!e.env.HISTORY_AUTO_UPDATE_ENABLED) return;
            if (
              (clearTimeout(this.autoUpdateTransactionsCounter),
              !this.autoUpdateTransactions)
            )
              return;
            const t = await this.getTransactions().catch(
              (e) => (console.warn(e), []),
            );
            (D($, this, ie).call(this, t),
              (this.autoUpdateTransactionsCounter = setTimeout(() => {
                this.initUpdateTransactions();
              }, U)));
          }
          async initUpdateBalances() {
            (this.updateBalanceTrackingConfig(),
              clearTimeout(this.autoUpdateBalancesCounter),
              this.autoUpdateBalances &&
                (await i.requestQueueState.waitForPermitted(
                  i.REQUEST_TYPE.INITIAL_BALANCES,
                ),
                await this.updateBalances(),
                await i.requestQueueState.setAsCompleted(
                  i.REQUEST_TYPE.INITIAL_BALANCES,
                ),
                (this.autoUpdateBalancesCounter = setTimeout(() => {
                  this.initUpdateBalances();
                }, U))));
          }
          loadTransactions(e) {
            D($, this, ie).call(
              this,
              e
                .map((e) => {
                  const t =
                    (null === e || void 0 === e ? void 0 : e.walletid) &&
                    this.getWallet(e.walletid);
                  if (!t) return null;
                  const a = e.otherSideAddress || e.recepient;
                  return (
                    this.setActivityChecked(t, o.ACTIVITY_TYPES.history, !0),
                    new g.default({
                      ticker: t.ticker,
                      parent: t.deprecatedParent,
                      name: t.name,
                      walletid: t.id,
                      explorer: e.explorer,
                      txid: e.txid,
                      txType: e.txType,
                      direction: e.direction,
                      otherSideAddress: a,
                      amount: e.amount,
                      datetime: new Date(Number(e.timestamp)),
                      memo: e.memo || "",
                      nonce: e.nonce,
                      confirmations: Number(e.confirmations) || 0,
                      alias: t.alias,
                      fee: e.fee || null,
                      feeTicker: e.feeTicker || "",
                    })
                  );
                })
                .filter((e) => !!e),
            );
          }
          getSumBalance(e) {
            return this.list().reduce(
              (t, a) => t + Number(a.balance) * e.getRate(a.ticker),
              0,
            );
          }
          findByFeature(e, t) {
            return (
              void 0 === t && (t = G.MAIN),
              [...I(K, this).walletsCollection[t].values()].filter(
                (t) => t instanceof d.default && t.isFeatureSupported(e),
              )
            );
          }
          getWallet(e) {
            if (!e) throw new Error("id should not be empty");
            const t = e.toUpperCase(),
              a = I(K, this).walletsCollection[G.MAIN].get(t),
              n = I(K, this).walletsCollection[G.NEW].get(t);
            return a || n;
          }
          getWalletsByIds(e) {
            return e.map((e) => this.getWallet(e)).filter((e) => !!e);
          }
          getWalletByParams(e) {
            var t;
            let {
              ticker: a,
              contract: n,
              address: r,
              parent: i,
              network: s,
              chainId: o,
              alias: l = G.MAIN,
            } = e;
            return null !==
              (t = this.getAllWalletsByParams({
                ticker: a,
                contract: n,
                parent: i,
                address: r,
                network: s,
                chainId: o,
                alias: l,
              })[0]) && void 0 !== t
              ? t
              : null;
          }
          getAllWalletsByParams(e) {
            let {
              ticker: t,
              contract: a,
              address: n,
              parent: r,
              network: i,
              chainId: s,
              alias: o = G.MAIN,
            } = e;
            const l = [];
            return (
              I(K, this).walletsCollection[o].forEach((e) => {
                e.isMatch({
                  ticker: t,
                  contract: a,
                  address: n,
                  parent: r,
                  network: i,
                  chainId: s,
                }) && l.push(e);
              }),
              l
            );
          }
          get transactions() {
            const e = Array.from(this)
              .reduce((e, t) => {
                var a;
                return (
                  null !== (a = t.transactions) &&
                    void 0 !== a &&
                    a.length &&
                    e.push(...t.transactions),
                  e
                );
              }, [])
              .filter(
                (e) => e && !Number.isNaN(new Date(e.datetime).getTime()),
              );
            return (0, r.default)(e).desc((e) => e.datetime);
          }
          async initTransactionsCache() {
            return this.loadTransactions(await f.default.selectTransactions());
          }
          removeTransaction(e) {
            const t = this.transactions.find((t) => {
              let { txid: a } = t;
              return a === e.txid;
            });
            if (t) {
              const a = this.getWallet(t.walletid),
                n = a.transactions.findIndex((a) => {
                  let { txid: n } = a;
                  return e.txid === t.txid;
                });
              n >= 0 && a.transactions.splice(n, 1);
            }
          }
          async getTransactionsByWallet(e, t) {
            if ((void 0 === t && (t = M), !this.isWalletActive(e))) return [];
            const a = [];
            let n,
              i = 0;
            const s = e.getTxLimit() || F;
            do {
              if (
                ((n = await this.fetchTransactions(e, i++)),
                await f.default.filterAndUpdateTransactions(n),
                n && n.length > 0)
              ) {
                a.push(...n);
                const { topic: t, payload: r } = (0, C.HISTORY_WALLET_UPDATED)(
                  e.id,
                  n,
                );
                v.default.emit(t, r);
              }
              v.default.emit("update::wallet-transactions", {
                ticker: e.ticker,
                alias: e.alias,
              });
            } while (n.length >= s && i < t);
            (this.setActivityChecked(e, o.ACTIVITY_TYPES.history, a.length > 0),
              v.default.emit("transactions::end-update"));
            const l = await f.default.selectTransactions({
                ticker: e.ticker,
                walletid: e.id,
                alias: G.MAIN,
              }),
              c =
                null === l || void 0 === l
                  ? void 0
                  : l
                      .filter((e) => {
                        let { amount: t } = e;
                        return "0" !== t;
                      })
                      .sort((e, t) => (e.txType > t.txType ? 1 : -1))
                      .sort((e, t) =>
                        t.datetime.getTime() > e.datetime.getTime() ? 1 : -1,
                      );
            return (
              this.loadTransactions(c),
              (0, r.default)(c || []).desc((e) => e.datetime)
            );
          }
          getTransactions() {
            return (
              I(j, this) ||
                R(
                  j,
                  this,
                  D($, this, se)
                    .call(this)
                    .finally(() => {
                      R(j, this, null);
                    }),
                ),
              I(j, this)
            );
          }
          get allTransactionsPromise() {
            return I(j, this);
          }
          enableSockets(e) {
            (void 0 === e && (e = G.MAIN),
              this.socket && this.socket.disconnect());
            const t = {
              id: this.hash,
              addresses: this.list(e)
                .map((e) =>
                  e.socket && e.address
                    ? {
                        ticker: e.ticker,
                        address: e.address,
                        name: e.name,
                        parent: e.deprecatedParent,
                        contract: e.contract,
                      }
                    : null,
                )
                .filter(Boolean),
              platform: p.default.getPlatform(),
              appVersion: p.default.getVersion(),
            };
            t.addresses.length > 0 && (this.socket = new y.default(t));
            try {
              this.balanceNotifier.socket = this.socket.socket;
            } catch (a) {
              console.warn("Failed to set balance notifier:", a);
            }
            I(K, this).walletsCollection.atomic.forEach((e) => {
              e instanceof d.default &&
                "function" === typeof e.connectSocket &&
                this.isWalletActive(e) &&
                e.connectSocket();
            });
          }
          disableSockets() {
            I(K, this).walletsCollection.atomic.forEach((e) => {
              "function" === typeof e.disconnectSocket && e.disconnectSocket();
            });
          }
          async updateBalances() {
            if (this.updateProcessFlag)
              return (console.warn("Update is cancelled"), null);
            ((this.updateProcessFlag = !0),
              await i.requestQueueState.waitForPermitted(
                i.REQUEST_TYPE.INITIAL_BALANCES,
              ));
            const e = this.getCoins(),
              t = [];
            for (let n = 0; n < e.length; n += 1) {
              const a = e[n];
              if (this.isWalletActive(a)) {
                const e = a.getInfo();
                (t.push(e),
                  e.then(() =>
                    this.setActivityChecked(
                      a,
                      o.ACTIVITY_TYPES.balance,
                      a.balance > 0,
                    ),
                  ));
              }
            }
            const a = await Promise.allSettled(t);
            return (
              a.forEach((t, a) => {
                ("rejected" === t.status &&
                  ((e[a].divisibleBalance = null), (e[a].balance = null)),
                  v.default.emit("update", {
                    ticker: e[a].ticker,
                    alias: e[a].alias,
                    id: e[a].id,
                  }));
              }),
              (this.updateProcessFlag = !1),
              v.default.emit("update::balances"),
              i.requestQueueState.setAsCompleted(
                i.REQUEST_TYPE.INITIAL_BALANCES,
              ),
              a
            );
          }
          getHiddenWallets() {
            const e = [];
            return (
              I(K, this).walletsCollection.atomic.forEach((t) => {
                !1 !== t.visibility || t.isCustom || e.push(t);
              }),
              e
            );
          }
          getTickers(e) {
            return (
              void 0 === e && (e = G.MAIN),
              this.list(e).map((e) => {
                let { ticker: t } = e;
                return t;
              })
            );
          }
          emitNewAtomicId(e) {
            v.default.emit(T.WALLETS.NEW_ATOMIC_ID, { atomicId: e });
          }
          async getFilters() {
            try {
              return (
                await b.filtersAndGroupsConfig.load(),
                b.filtersAndGroupsConfig.getFilterNames()
              );
            } catch (e) {
              return (m.default.error({ instance: this, error: e }), []);
            }
          }
          async getWalletsByFilter(e) {
            if (!e) throw new Error("filterName is not defined");
            try {
              return (
                await b.filtersAndGroupsConfig.load(),
                this.getWalletsByIds(
                  b.filtersAndGroupsConfig.getCoinsForFilter(e),
                )
              );
            } catch (t) {
              return (m.default.error({ instance: this, error: t }), []);
            }
          }
          async getAvailableWalletsByFilter(e, t) {
            void 0 === t && (t = []);
            try {
              const a = await this.getWalletsByFilter(e);
              return a.filter((e) => t.includes(e.id));
            } catch (a) {
              return (m.default.error({ instance: this, error: a }), []);
            }
          }
          async getWalletsGrouped() {
            await b.filtersAndGroupsConfig.load();
            const e = b.filtersAndGroupsConfig.getGroups();
            return e.map((e) => ({
              name: e.name,
              coins: this.getWalletsByIds(e.coinIds),
            }));
          }
          async activateWallet(e) {
            return this.isWalletActive(e)
              ? (e.address || (await e.activate()), e)
              : ("ONT" === e.id &&
                  (await this.activateWallet(
                    this.getWallet(e.deprecatedParent),
                  )),
                await e.activate(),
                v.default.emit(T.WALLETS.UPDATE),
                e.getInfo(),
                e);
          }
          async createCustomWallet(e, t, a) {
            if (
              (void 0 === a && (a = "EVM"),
              this.getWallet((0, P.generateId)({ ...t, walletType: a })))
            )
              throw new Error(
                `CreateEVMWallet: Wallet ${t.ticker} already exists!`,
              );
            const n = await I(V, this).getByPassword(E.MNEMONIC_KEY, e),
              { seed: r } = await D($, this, z).call(this, {
                phrase: n,
                password: e,
                shouldSave: !1,
              }),
              i = (0, A.createEVMCoin)(t),
              s = await D($, this, ee).call(
                this,
                i,
                {},
                { seed: r, phrase: n },
              );
            try {
              await D($, this, le).call(this, s);
            } catch (o) {
              throw (
                m.default.error({
                  instance: this,
                  error: i.id + ": Failed to save newly created keys",
                }),
                new Error(o)
              );
            }
            return (
              this.addWallet(i),
              this.insertCustomWalletToDb({
                walletParams: { id: i.id, ...t },
                walletType: a,
              }),
              i
            );
          }
          insertCustomWalletToDb(e) {
            let { walletParams: t, walletType: a } = e;
            return i.db.customWallets.put({ ...t, walletType: a });
          }
          removeWallet(e) {
            let { id: t, alias: a } = e;
            if (!t || !a)
              throw new Error(
                "RemoveWallet: Arguments [id, alias] should be defined!",
              );
            const n = this.getWallet(t);
            return (
              n.contract &&
                n.removeTokenFromDb &&
                n.removeTokenFromDb(n.contract),
              I(K, this).walletsCollection[a].delete(t.toUpperCase())
            );
          }
          addWallet(e) {
            if (e && (!e.id || !e.alias))
              throw new Error(
                "AddWallet: Arguments [id, alias] should be defined!",
              );
            return (
              e instanceof d.default && e.install(this),
              I(K, this).walletsCollection[e.alias].set(e.id.toUpperCase(), e)
            );
          }
          setVault(e) {
            R(V, this, e);
          }
          async isMnemonicStored() {
            return Boolean(
              await I(V, this).exists(E.MNEMONIC_KEY).catch(console.error),
            );
          }
          setGetPasswordCallback(e) {
            this.getPassword = e;
          }
          loadAddresses() {
            return JSON.parse(localStorage.getItem(E.ADDRESSES_KEY));
          }
          async load(e) {
            const t = await I(V, this).getByPassword(E.WALLETS_KEY, e),
              a = JSON.parse(t),
              n = this.loadAddresses() || a;
            return a.map((e) => {
              var t;
              return Object.assign(
                {
                  address:
                    null ===
                      (t = n.find((t) => {
                        let { id: a } = t;
                        return a === e.id;
                      })) || void 0 === t
                      ? void 0
                      : t.address,
                },
                e,
              );
            });
          }
          async checkPassword(e) {
            try {
              const t = await I(V, this).checkPassword(e);
              return t;
            } catch (t) {
              return !1;
            }
          }
          async loadKeysData(e) {
            const t = await this.load(e);
            return this.getCoins().map((e) => {
              const a = t.find((t) => t.id === e.id);
              if (!a)
                return (
                  console.warn(`[${e.id}] privateKey not found`),
                  {
                    id: e.id,
                    privateKey: "",
                    address: e.address || "",
                    name: e.name,
                    ticker: e.ticker,
                  }
                );
              const n = {
                id: e.id,
                privateKey: a.privateKey,
                address: e.address,
                name: e.name,
                ticker: e.ticker,
              };
              return (
                "EOS" === e.ticker &&
                  (n.additionalKeys = JSON.parse(a.privateKey)),
                "ATOM" === e.ticker && (n.privateKey = a.privateKey),
                "HBAR" === e.ticker && (n.address = e.publicKey),
                "XMR" === e.ticker &&
                  (n.additionalKeys = {
                    privateKeyView: a.privateKey.privateKeyView,
                    privateKeySpend: a.privateKey.privateKeySpend,
                    publicKeySpend: a.privateKey.publicKeySpend,
                  }),
                "ADA" === e.ticker &&
                  (n.additionalKeys = {
                    shelleyPrivateKey: a.privateKey.shelleyKey,
                    byronPrivateKey: a.privateKey.byronKey,
                    shelleyAddress: e.address,
                    byronAddress: a.privateKey.byronAddress,
                  }),
                n
              );
            });
          }
          changePassword(e, t) {
            return I(V, this).changePassword(e, t);
          }
          removeMnemonic() {
            return I(V, this).remove("general_mnemonic");
          }
        }
        function H(e) {
          return (
            void 0 === e && (e = G.MAIN),
            I(K, this).walletsCollection[e].values()
          );
        }
        async function Y(e) {
          (this.addWallet(e),
            "function" === typeof e.loadTokensList &&
              (await e.loadTokensList(this)));
        }
        async function Q() {
          return (
            await Promise.all([
              a.e(0),
              a.e(1),
              a.e(18),
              a.e(15),
              a.e(17),
              a.e(288),
            ]).then(a.t.bind(null, 2664, 7))
          ).default;
        }
        async function z(e) {
          let { password: t, phrase: a, shouldSave: n = !0 } = e;
          const r = await D($, this, Q).call(this),
            i = new r(a),
            s = i.phrase.toString();
          return (
            n && (await D($, this, J).call(this, s, t)),
            { mnemonic: i, phrase: s, seed: i.toSeed() }
          );
        }
        async function J(e, t) {
          (I(V, this).setPassword(t),
            I(V, this).set(E.MNEMONIC_KEY, e),
            (this.hash = (0, s.default)((0, s.default)(e))));
        }
        async function X(e) {
          (clearTimeout(this.autoUpdateCoinsDataCounter),
            (this.autoUpdateCoinsDataCounter = setTimeout(async () => {
              const t = await l.default.get(c.ConfigKey.WalletsFee, !0);
              (t && D($, this, Z).call(this, t, e),
                D($, this, X).call(this, e));
            }, B)));
        }
        async function Z(e, t) {
          const a = [];
          if (
            (e.forEach((e) => {
              const t = e.id && this.getWallet(e.id);
              if (!t) return a.push(e);
              try {
                var n;
                if (e.className.endsWith("Token"))
                  Object.values(t.tokens).forEach((t) => {
                    t.updateTokenParamsFromServer(e);
                  });
                else
                  null === (n = t.updateCoinParamsFromServer) ||
                    void 0 === n ||
                    n.call(t, e);
              } catch (r) {
                m.default.error({
                  instance: this,
                  error: new Error(
                    `Failed updating wallet #${t.id}: ${r.message}`,
                  ),
                });
              }
            }),
            a.length > 0)
          ) {
            const e = { params: { atomicId: this.hash }, walletConfigs: a },
              n = new w.default(e, (e) => {
                try {
                  ((e.alias = G.NEW), D($, this, Y).call(this, e));
                } catch (t) {
                  console.error(t);
                }
              });
            await n.installCoins();
            const r = await D($, this, te).call(this, t, G.NEW);
            (await D($, this, le).call(this, r),
              v.default.emit(T.WALLETS.NEW_COINS_LOADED));
          }
          v.default.emit(T.WALLETS.UPDATE);
        }
        async function ee(e, t, a) {
          var n, r;
          if ((void 0 === t && (t = {}), !(e instanceof d.default)))
            throw new TypeError(`[${e.id}] wallet is not a Coin`);
          let i = !1;
          if (
            (null !== (n = t) && void 0 !== n && n.address
              ? e.setAddress(t.address)
              : (i = !0),
            null !== (r = t) && void 0 !== r && r.privateKey)
          )
            try {
              e.setPrivateKey(t.privateKey, a.phrase);
            } catch (o) {
              i = !0;
            }
          else i = !0;
          let s = {};
          if (i) {
            v.default.emit(T.WALLETS.START_LOADING, e);
            try {
              s = await e.loadWallet(a.seed, a.phrase);
            } catch (o) {
              (v.default.emit(T.WALLETS.RAISE_LOADING_ERROR, {
                wallet: e.name,
              }),
                m.default.error({ instance: e, error: o }));
            }
            v.default.emit(T.WALLETS.FINISH_LOADING, e);
          }
          if ("function" === typeof e.fetchUserTokens) {
            const t = e.fetchUserTokens(this);
            e.shouldSkipTokensFetchAwait || (await t);
          }
          return { ...t, ...s };
        }
        async function te(e, t) {
          (void 0 === t && (t = G.MAIN),
            t === G.MAIN &&
              v.default.emit(T.WALLETS.START_LOADING_ALL, this.list(t).length),
            (this.balanceNotifier.hash = this.hash),
            this.emitNewAtomicId(this.hash));
          const a = await Promise.allSettled(
            this.getCoins(t).map(async (t) => {
              t.transactions.length > 0 && (t.transactions = []);
              const a = await D($, this, ee).call(this, t, void 0, e);
              if (!a) throw new Error(t.id + " privateKey is not loaded");
              return a;
            }),
          );
          return (
            this.disabledSockets || this.enableSockets(t),
            t === G.MAIN &&
              (v.default.emit(T.WALLETS.FINISH_LOADING_ALL),
              v.default.emit(T.WALLETS.WALLETS_READY_TO_DISPLAY)),
            a.filter((e) => "fulfilled" === e.status).map((e) => e.value)
          );
        }
        async function ae(e, t, a) {
          (void 0 === a && (a = G.MAIN), await this.initialize(t, a));
          const n = this.getCoins().filter(
            (t) =>
              !e.find((e) => {
                let { id: a } = e;
                return t.id === a;
              }),
          );
          if (
            (this.emitNewAtomicId(this.hash),
            (this.balanceNotifier.hash = this.hash),
            n.length > 0)
          ) {
            v.default.emit(T.WALLETS.START_LOADING_ALL, n.length);
            const a = await Promise.all(
              n.map((e) => D($, this, ee).call(this, e, void 0, t)),
            );
            (await D($, this, oe).call(this, Object.values(e).concat(a)),
              v.default.emit(T.WALLETS.WALLETS_READY_TO_DISPLAY));
          }
          const r = [];
          (e.forEach(async (e) => {
            const a = e.id && this.getWallet(e.id);
            a && r.push(D($, this, ee).call(this, a, e, t));
          }),
            Promise.allSettled(r).then(() => {
              (v.default.emit(T.WALLETS.FINISH_LOADING_ALL),
                this.disabledSockets || this.enableSockets(a));
            }),
            this.disabledSockets || this.enableSockets(a));
        }
        async function ne(e, t) {
          try {
            const a = await e.getNftList(t);
            (await h.default.set(e, a),
              v.default.emit("update::nft::list::wallet", {
                ticker: e.ticker,
                id: e.id,
              }));
          } catch (a) {
            console.warn(a);
          }
        }
        async function re(e) {
          return Array.from(this)
            .filter((e) => e.address && e.isNftSupported())
            .map((t) => D($, this, ne).call(this, t, e));
        }
        function ie(e) {
          e.forEach((e) => {
            const t = e.walletid && this.getWallet(e.walletid);
            if (null === t || void 0 === t || !t.transactions) return;
            const a = t.transactions.findIndex((t) => {
              let { txid: a } = t;
              return e.txid === a;
            });
            a > -1 ? (t.transactions[a] = e) : t.transactions.push(e);
          });
        }
        async function se() {
          const e = [],
            t = this.getCoins();
          for (let n = t.length - 1; n >= 0; n -= 1) {
            const r = t[n];
            if (this.isWalletActive(r)) {
              v.default.emit("transactions::start-update");
              try {
                const t = await this.fetchTransactions(r);
                if (
                  (await f.default.filterAndUpdateTransactions(t),
                  t && t.length > 0)
                ) {
                  e.push(...t);
                  const { topic: a, payload: n } = (0,
                  C.HISTORY_WALLET_UPDATED)(r.id, t);
                  v.default.emit(a, n);
                }
                (this.setActivityChecked(
                  r,
                  o.ACTIVITY_TYPES.history,
                  t.length > 0,
                ),
                  v.default.emit("update::wallet-transactions", {
                    ticker: r.ticker,
                    alias: r.alias,
                  }));
              } catch (a) {
                console.warn(a);
              }
            }
          }
          return (
            i.requestQueueState.setAsCompleted(
              i.REQUEST_TYPE.INITIAL_TRANSACTIONS,
            ),
            v.default.emit("transactions::end-update"),
            this.loadTransactions(e),
            (0, r.default)(e)
              .desc((e) => e.datetime)
              .filter(Boolean)
          );
        }
        async function oe(e) {
          (await I(V, this).set(
            E.WALLETS_KEY,
            JSON.stringify(
              e.map((e) => {
                let { id: t, privateKey: a } = e;
                return { id: t, privateKey: a };
              }),
            ),
          ),
            localStorage.setItem(
              E.ADDRESSES_KEY,
              JSON.stringify(
                e.map((e) => {
                  let { id: t, balance: a, address: n } = e;
                  return { id: t, balance: a, address: n };
                }),
              ),
            ));
        }
        async function le(e) {
          const t = await I(V, this).get(E.WALLETS_KEY),
            a = JSON.parse(t);
          return (a.push(e), D($, this, oe).call(this, a));
        }
        t.Wallets = Wallets;
        t.default = new Wallets();
      }).call(this, a(18));
    },
    1242: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(14)),
        i = n(a(28));
      const s = "https://resolve.unstoppabledomains.com",
        o = "da938e74-b9c5-4895-b059-8eb7960acebf",
        l = "https://api.prd.space.id/v1/",
        c = /\.[\w|\d|-]+$/;
      class DomainsPlugin {
        install(e) {
          const t = e.validateAddress;
          e.validateAddress = async function (a) {
            const n = await t.call(e, a || e.address);
            return n || d.call(DomainsPlugin, a, this.id, this.parent);
          };
        }
      }
      async function d(e, t, a) {
        if (!c.test(e)) return null;
        const n = await Promise.all(
          u._.map(async (n) => {
            const { data: r } = await n.http
              .get(n.getUrl(e, t))
              .catch(
                (e) => (
                  i.default.error({ instance: this, error: e }),
                  { data: {} }
                ),
              );
            return n.extractAddress(r, t, a);
          }),
        );
        return n.reduce((e, t) => (null !== e && void 0 !== e ? e : t));
      }
      var u = {
        _: [
          {
            http: r.default.create({
              baseURL: s,
              headers: { Authorization: "Bearer " + o },
            }),
            getUrl: (e) => "/domains/" + e.toLowerCase(),
            extractAddress: (e, t, a) => {
              var n;
              let { records: r } = e;
              return null !==
                (n =
                  (null === r || void 0 === r
                    ? void 0
                    : r[`crypto.${t}.address`]) ||
                  (null === r || void 0 === r
                    ? void 0
                    : r[`crypto.${a}.version.${t}.address`])) && void 0 !== n
                ? n
                : null;
            },
          },
          {
            http: r.default.create({ baseURL: l }),
            getUrl: (e, t) => {
              let a;
              switch (t) {
                case "ARB":
                  a = "arb1";
                  break;
                case "BSC":
                  a = "bnb";
                  break;
                case "BNB":
                  a = "not-valid-domain";
                  break;
                default:
                  a = t.toLowerCase();
              }
              return `/getAddress?tld=${a}&domain=${e.toLowerCase()}`;
            },
            extractAddress: (e, t, a) => {
              let { code: n, address: r } = e;
              return 0 === n &&
                "0x0000000000000000000000000000000000000000" !== r
                ? r
                : null;
            },
          },
        ],
      };
      t.default = DomainsPlugin;
    },
    1271: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      const n = {
        BTCCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(370),
          ]).then(a.t.bind(null, 2665, 7)),
        ETHCoin: () =>
          Promise.all([
            a.e(0),
            a.e(7),
            a.e(8),
            a.e(10),
            a.e(14),
            a.e(13),
            a.e(12),
            a.e(11),
            a.e(273),
          ]).then(a.t.bind(null, 2666, 7)),
        FLRCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(312),
          ]).then(a.t.bind(null, 2667, 7)),
        EGLDCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(374),
          ]).then(a.t.bind(null, 2668, 7)),
        BNBCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(327),
          ]).then(a.t.bind(null, 2669, 7)),
        DOGECoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(352),
          ]).then(a.t.bind(null, 2670, 7)),
        SOLCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(233),
          ]).then(a.bind(null, 2671)),
        ADACoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(347),
          ]).then(a.bind(null, 2672)),
        ZILCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(305),
            a.e(429),
            a.e(426),
            a.e(430),
          ]).then(a.t.bind(null, 2673, 7)),
        MATICCoin: () =>
          Promise.all([
            a.e(0),
            a.e(7),
            a.e(8),
            a.e(10),
            a.e(14),
            a.e(13),
            a.e(12),
            a.e(11),
            a.e(286),
          ]).then(a.t.bind(null, 2674, 7)),
        DOTCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(340),
          ]).then(a.t.bind(null, 2675, 7)),
        BSCCoin: () =>
          Promise.all([
            a.e(0),
            a.e(7),
            a.e(8),
            a.e(10),
            a.e(14),
            a.e(13),
            a.e(12),
            a.e(11),
            a.e(295),
          ]).then(a.t.bind(null, 2676, 7)),
        TRXCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(7),
            a.e(151),
            a.e(276),
            a.e(314),
            a.e(152),
            a.e(440),
            a.e(134),
          ]).then(a.t.bind(null, 2677, 7)),
        XRPCoin: () => a.e(420).then(a.t.bind(null, 2678, 7)),
        ATOMCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(315),
          ]).then(a.t.bind(null, 2679, 7)),
        BANDCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(328),
          ]).then(a.t.bind(null, 2680, 7)),
        ICXCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(342),
          ]).then(a.t.bind(null, 2681, 7)),
        LTCCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(375),
          ]).then(a.t.bind(null, 2682, 7)),
        NEOCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(355),
          ]).then(a.t.bind(null, 2683, 7)),
        ONTCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(20),
            a.e(127),
            a.e(227),
            a.e(202),
            a.e(437),
          ]).then(a.t.bind(null, 2684, 7)),
        RVNCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(378),
          ]).then(a.t.bind(null, 2685, 7)),
        XLMCoin: () =>
          Promise.all([a.e(124), a.e(166), a.e(177), a.e(321)]).then(
            a.t.bind(null, 2686, 7),
          ),
        XTZCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(296),
          ]).then(a.t.bind(null, 2687, 7)),
        XVGCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(379),
          ]).then(a.t.bind(null, 2688, 7)),
        ETCCoin: () => a.e(397).then(a.t.bind(null, 2689, 7)),
        ZECCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(356),
          ]).then(a.t.bind(null, 2690, 7)),
        VETCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(20),
            a.e(164),
          ]).then(a.t.bind(null, 2691, 7)),
        XEMCoin: () =>
          Promise.all([
            a.e(0),
            a.e(241),
            a.e(139),
            a.e(401),
            a.e(136),
            a.e(211),
            a.e(248),
            a.e(289),
          ]).then(a.t.bind(null, 2692, 7)),
        KMDCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(345),
          ]).then(a.t.bind(null, 2693, 7)),
        ALGOCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(351),
          ]).then(a.t.bind(null, 2694, 7)),
        DASHCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(372),
          ]).then(a.t.bind(null, 2695, 7)),
        HBARCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(7),
            a.e(256),
            a.e(171),
            a.e(269),
            a.e(254),
            a.e(428),
            a.e(168),
            a.e(272),
            a.e(190),
            a.e(210),
            a.e(186),
            a.e(175),
          ]).then(a.t.bind(null, 2696, 7)),
        QTUMCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(377),
          ]).then(a.t.bind(null, 2697, 7)),
        NANOCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(376),
          ]).then(a.t.bind(null, 2698, 7)),
        WAVESCoin: () => a.e(399).then(a.t.bind(null, 2699, 7)),
        ARKCoin: () => a.e(418).then(a.t.bind(null, 2700, 7)),
        BCHCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(368),
          ]).then(a.t.bind(null, 2701, 7)),
        BSVCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(369),
          ]).then(a.t.bind(null, 2702, 7)),
        BTGCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(371),
          ]).then(a.t.bind(null, 2703, 7)),
        DCRCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(339),
          ]).then(a.t.bind(null, 2704, 7)),
        DGBCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(373),
          ]).then(a.t.bind(null, 2705, 7)),
        XMRCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(236),
          ]).then(a.t.bind(null, 2706, 7)),
        EOSCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(149),
          ]).then(a.t.bind(null, 2707, 7)),
        GASCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(353),
          ]).then(a.t.bind(null, 2708, 7)),
        NEO3Coin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(354),
          ]).then(a.t.bind(null, 2709, 7)),
        NEARCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(252),
            a.e(191),
          ]).then(a.t.bind(null, 2710, 7)),
        AVAXCoin: () =>
          Promise.all([
            a.e(0),
            a.e(9),
            a.e(7),
            a.e(8),
            a.e(140),
            a.e(425),
            a.e(282),
            a.e(240),
            a.e(160),
          ]).then(a.t.bind(null, 2711, 7)),
        LUNCCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(234),
            a.e(275),
            a.e(416),
            a.e(293),
            a.e(147),
            a.e(250),
            a.e(216),
            a.e(155),
            a.e(206),
            a.e(257),
            a.e(277),
            a.e(264),
            a.e(303),
            a.e(238),
          ]).then(a.t.bind(null, 2712, 7)),
        LUNACoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(235),
            a.e(284),
            a.e(417),
            a.e(294),
            a.e(148),
            a.e(251),
            a.e(217),
            a.e(156),
            a.e(207),
            a.e(258),
            a.e(278),
            a.e(265),
            a.e(304),
            a.e(239),
          ]).then(a.t.bind(null, 2713, 7)),
        THETACoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(337),
          ]).then(a.t.bind(null, 2714, 7)),
        APTCoin: () => a.e(167).then(a.t.bind(null, 2715, 7)),
        OSMOCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(346),
          ]).then(a.t.bind(null, 2716, 7)),
        KAVACoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(344),
          ]).then(a.t.bind(null, 2717, 7)),
        FTMCoin: () =>
          Promise.all([
            a.e(0),
            a.e(7),
            a.e(8),
            a.e(10),
            a.e(14),
            a.e(13),
            a.e(12),
            a.e(11),
            a.e(302),
          ]).then(a.t.bind(null, 2718, 7)),
        TONCoin: () =>
          Promise.all([a.e(37), a.e(135), a.e(137), a.e(185)]).then(
            a.t.bind(null, 2719, 7),
          ),
        FETCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(341),
          ]).then(a.t.bind(null, 2720, 7)),
        FILCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(391),
          ]).then(a.t.bind(null, 2721, 7)),
        OPCoin: () => a.e(398).then(a.t.bind(null, 2722, 7)),
        INJCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(343),
          ]).then(a.t.bind(null, 2723, 7)),
        ARBCoin: () =>
          Promise.all([
            a.e(0),
            a.e(7),
            a.e(8),
            a.e(10),
            a.e(14),
            a.e(13),
            a.e(12),
            a.e(11),
            a.e(285),
          ]).then(a.t.bind(null, 2724, 7)),
        CROCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(338),
          ]).then(a.t.bind(null, 2725, 7)),
        SUICoin: () =>
          Promise.all([a.e(313), a.e(226)]).then(a.t.bind(null, 2726, 7)),
        EVMCoin: () => Promise.resolve().then(a.t.bind(null, 241, 7)),
        COSMOSCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(220),
            a.e(145),
            a.e(229),
            a.e(325),
            a.e(197),
            a.e(195),
            a.e(280),
            a.e(330),
            a.e(316),
            a.e(359),
            a.e(298),
            a.e(243),
            a.e(433),
          ]).then(a.t.bind(null, 2657, 7)),
        STXCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(270),
          ]).then(a.t.bind(null, 2727, 7)),
        LUMIACoin: () => a.e(432).then(a.t.bind(null, 2728, 7)),
        MONCoin: () => a.e(419).then(a.t.bind(null, 2729, 7)),
        BABYCoin: () =>
          Promise.all([
            a.e(0),
            a.e(1),
            a.e(2),
            a.e(5),
            a.e(4),
            a.e(3),
            a.e(6),
            a.e(9),
            a.e(221),
            a.e(146),
            a.e(230),
            a.e(326),
            a.e(194),
            a.e(249),
            a.e(196),
            a.e(281),
            a.e(331),
            a.e(317),
            a.e(360),
            a.e(299),
            a.e(244),
            a.e(434),
          ]).then(a.bind(null, 2730)),
      };
      t.default = n;
    },
    132: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(69)),
        i = n(a(28));
      class AtomicError extends Error {
        constructor(e) {
          var t, a;
          e.error.data && (e.error = Object.values(e.error.data).toString());
          const n =
            e.instance.ticker ||
            (e.instance.wallet && e.instance.wallet.ticker);
          let s = "";
          if (e.error.response) {
            const t = e.error.response.status;
            let a = "";
            (e.error.response.data && e.error.response.data.message
              ? (a = e.error.response.data.message)
              : e.error.response.data
                ? (a =
                    "string" === typeof e.error.response.data
                      ? e.error.response.data
                      : e.error.response.data.error)
                : e.error.response.detail && (a = e.error.response.detail),
              (s = `${t} - ${a}`));
          } else s = "Unknown error: - " + e.error;
          (super(
            null === (t = e.error) || void 0 === t ? void 0 : t.toString(),
          ),
            (0, r.default)(this, "defaultType", "Unknown"));
          const o = {
            type: null !== (a = e.type) && void 0 !== a ? a : this.defaultType,
            error: s,
            currency: n,
            instance: e.instance,
            stack: this.stack,
          };
          (e.url && (o.url = e.url),
            i.default.error(o),
            (this.name = this.constructor.name));
        }
      }
      t.default = AtomicError;
    },
    158: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default =
          t.TOKEN_PROVIDER_OPERATION =
          t.TOKEN_HISTORY_PROVIDER_OPERATION =
          t.SOCKET_PROVIDER_OPERATION =
          t.SEND_PROVIDER_OPERATION =
          t.NODE_PROVIDER_OPERATION =
          t.NFT_SEND_PROVIDER_OPERATION =
          t.HISTORY_PROVIDER_OPERATION =
          t.BALANCE_PROVIDER_OPERATION =
            void 0));
      var r = n(a(28));
      ((t.NODE_PROVIDER_OPERATION = "node"),
        (t.BALANCE_PROVIDER_OPERATION = "balance"),
        (t.HISTORY_PROVIDER_OPERATION = "history"),
        (t.TOKEN_PROVIDER_OPERATION = "token"),
        (t.TOKEN_HISTORY_PROVIDER_OPERATION = "token-history"),
        (t.SEND_PROVIDER_OPERATION = "send"),
        (t.NFT_SEND_PROVIDER_OPERATION = "nft-send"),
        (t.SOCKET_PROVIDER_OPERATION = "socket"));
      const i = (e) =>
        class extends e {
          processExplorerConfig(e) {
            const t = super.processExplorerConfig(e);
            return t && Array.isArray(e.usedFor)
              ? (0 === e.usedFor.length
                  ? (this.defaultProvider = t)
                  : (this.providersMap || (this.providersMap = {}),
                    e.usedFor.forEach((e) => {
                      this.providersMap[e] = t;
                    })),
                t)
              : t;
          }
          getProvider(e) {
            var t, a, n;
            return null !==
              (t =
                null !==
                  (a =
                    null === (n = this.providersMap) || void 0 === n
                      ? void 0
                      : n[e]) && void 0 !== a
                  ? a
                  : this.defaultProvider) && void 0 !== t
              ? t
              : this.explorer;
          }
          async getBalance() {
            return this.getProvider("balance").getBalance(this.address, !0);
          }
          async getTransactions(e) {
            try {
              if (!this.address)
                throw new Error(
                  `[${this.ticker}] getTransactions error: address is not loaded`,
                );
              return this.getProvider("history").getTransactions({
                ...e[0],
                address: this.address,
              });
            } catch (t) {
              return (console.error(t), this.transactions || []);
            }
          }
          async getInfo() {
            const e = await this.getBalance();
            return ((this.balance = e), { balance: e });
          }
          async getUnspentOutputs(e, t) {
            return (
              void 0 === e && (e = this.address),
              t ||
                "function" !== typeof this.getScriptPubKey ||
                (t = await this.getScriptPubKey()),
              this.getProvider("utxo").getUnspentOutputs(e, t)
            );
          }
          getUTXO() {
            return this.getProvider("utxo").getUnspentOutputs(this.address);
          }
          sendTransaction(e) {
            return this.getProvider("send").sendTransaction(e);
          }
          getTransaction(e) {
            return this.getProvider("tx").getTransaction(this.address, e);
          }
          updateCoinParamsFromServer(e) {
            (super.updateCoinParamsFromServer(e),
              e.chainID && (this.chainId = e.chainID));
            try {
              return (
                e.feeData &&
                  ((this.fee = e.feeData.fee),
                  e.feeData.stakingContract &&
                    (this.stakingContract = e.feeData.stakingContract),
                  e.feeData.stakingProxyContract &&
                    (this.stakingProxyContract =
                      e.feeData.stakingProxyContract),
                  e.feeData.stakingFeeGas &&
                    (this.stakingFeeGas = e.feeData.stakingFeeGas.toString()),
                  e.feeData.reStakingFeeGas &&
                    (this.reStakingFeeGas = e.feeData.reStakingFeeGas),
                  e.feeData.unstakingFeeGas &&
                    (this.unstakingFeeGas =
                      e.feeData.unstakingFeeGas.toString()),
                  e.feeData.claimFeeGas &&
                    (this.claimFeeGas = e.feeData.claimFeeGas.toString()),
                  e.feeData.tokenFeeGas &&
                    (this.tokenFeeGas = e.feeData.tokenFeeGas),
                  e.feeData.sendFeeGas &&
                    (this.sendFeeGas = e.feeData.sendFeeGas),
                  e.feeData.defaultGasPrice &&
                    (this.sendFeeGas = e.feeData.defaultGasPrice),
                  e.feeData.gasPriceCoefficient &&
                    (this.sendFeeGas = e.feeData.gasPriceCoefficient),
                  e.feeData.defaultMaxGasPrice &&
                    (this.sendFeeGas = e.feeData.defaultMaxGasPrice),
                  e.feeData.gasLimitCoefficient &&
                    (this.sendFeeGas = e.feeData.gasLimitCoefficient),
                  e.feeData.gasLimit && (this.sendFeeGas = e.feeData.gasLimit),
                  e.feeData.resendTimeout &&
                    (this.sendFeeGas = e.feeData.resendTimeout)),
                !0
              );
            } catch (t) {
              return (
                (t.message = `[${this.ticker}] updateCoinParamsFromServer error: ${t.message || "Unknown error"}`),
                r.default.error({ instance: this, error: t }),
                !1
              );
            }
          }
        };
      t.default = i;
    },
    19: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "AjvValidationError", {
          enumerable: !0,
          get: function () {
            return f.default;
          },
        }),
        Object.defineProperty(t, "DuplicatedConfigRegistrationError", {
          enumerable: !0,
          get: function () {
            return p.default;
          },
        }),
        Object.defineProperty(t, "ExchangeConfirmsCalculationError", {
          enumerable: !0,
          get: function () {
            return y.default;
          },
        }),
        Object.defineProperty(t, "ExchangeConnectionError", {
          enumerable: !0,
          get: function () {
            return r.default;
          },
        }),
        Object.defineProperty(t, "ExchangeValidationError", {
          enumerable: !0,
          get: function () {
            return i.default;
          },
        }),
        Object.defineProperty(t, "ExplorerRequestError", {
          enumerable: !0,
          get: function () {
            return s.default;
          },
        }),
        Object.defineProperty(t, "ExternalError", {
          enumerable: !0,
          get: function () {
            return l.default;
          },
        }),
        Object.defineProperty(t, "InsufficientFundsError", {
          enumerable: !0,
          get: function () {
            return u.default;
          },
        }),
        Object.defineProperty(t, "InternalError", {
          enumerable: !0,
          get: function () {
            return o.default;
          },
        }),
        Object.defineProperty(t, "RequestStatusCodeError", {
          enumerable: !0,
          get: function () {
            return d.default;
          },
        }),
        Object.defineProperty(t, "UndeclaredAbstractMethodError", {
          enumerable: !0,
          get: function () {
            return h.default;
          },
        }),
        Object.defineProperty(t, "UnknownConfigKeyError", {
          enumerable: !0,
          get: function () {
            return m.default;
          },
        }),
        Object.defineProperty(t, "WalletError", {
          enumerable: !0,
          get: function () {
            return c.default;
          },
        }));
      var r = n(a(982)),
        i = n(a(983)),
        s = n(a(984)),
        o = n(a(432)),
        l = n(a(987)),
        c = n(a(988)),
        d = n(a(989)),
        u = n(a(990)),
        h = n(a(991)),
        f = n(a(992)),
        m = n(a(993)),
        p = n(a(994)),
        y = n(a(995));
    },
    193: function (e, t, a) {
      "use strict";
      (a.r(t),
        a.d(t, "ExchangerV2", function () {
          return ExchangerV2_ExchangerV2;
        }),
        a.d(t, "exchangerV2", function () {
          return j;
        }));
      var n = a(14),
        r = a.n(n),
        i = a(37),
        s = a.n(i),
        o = a(26),
        l = a.n(o),
        c = a(35),
        d = Object.defineProperty,
        u = Object.defineProperties,
        h = Object.getOwnPropertyDescriptors,
        f = Object.getOwnPropertySymbols,
        m = Object.prototype.hasOwnProperty,
        p = Object.prototype.propertyIsEnumerable,
        y = (e, t, a) =>
          t in e
            ? d(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: a,
              })
            : (e[t] = a),
        g = (e, t) => {
          for (var a in t || (t = {})) m.call(t, a) && y(e, a, t[a]);
          if (f) for (var a of f(t)) p.call(t, a) && y(e, a, t[a]);
          return e;
        },
        w = (e, t) => u(e, h(t));
      const T = "https://payments.atomicwallet.io",
        v = "/v1",
        b = "fiats",
        C = "assets",
        k = "min-max",
        E = "estimation",
        A = "transactions",
        P = "subscriptions",
        _ = "x-atomic-id",
        S = { Buy: "buy", Subscription: "subscription" },
        L = w(g({}, S), { Move: "move" });
      function N(e) {
        return Object.entries(null != e ? e : {}).reduce((e, t, a) => {
          const [n, r] = t;
          return (
            "object" !== typeof r
              ? (e[n] = r)
              : Object.entries(r).forEach(([t, a]) => {
                  e[`${n}_${t}`] = a;
                }),
            e
          );
        }, {});
      }
      var O = ((e) => ((e["GET"] = "get"), (e["POST"] = "post"), e))(O || {}),
        x = Object.defineProperty,
        I = Object.defineProperties,
        R = Object.getOwnPropertyDescriptors,
        D = Object.getOwnPropertySymbols,
        M = Object.prototype.hasOwnProperty,
        F = Object.prototype.propertyIsEnumerable,
        U = (e, t, a) =>
          t in e
            ? x(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: a,
              })
            : (e[t] = a),
        B = (e, t) => {
          for (var a in t || (t = {})) M.call(t, a) && U(e, a, t[a]);
          if (D) for (var a of D(t)) F.call(t, a) && U(e, a, t[a]);
          return e;
        },
        G = (e, t) => I(e, R(t)),
        W = (e, t) => {
          var a = {};
          for (var n in e) M.call(e, n) && t.indexOf(n) < 0 && (a[n] = e[n]);
          if (null != e && D)
            for (var n of D(e))
              t.indexOf(n) < 0 && F.call(e, n) && (a[n] = e[n]);
          return a;
        },
        K = (e, t, a) =>
          new Promise((n, r) => {
            var i = (e) => {
                try {
                  o(a.next(e));
                } catch (t) {
                  r(t);
                }
              },
              s = (e) => {
                try {
                  o(a.throw(e));
                } catch (t) {
                  r(t);
                }
              },
              o = (e) =>
                e.done ? n(e.value) : Promise.resolve(e.value).then(i, s);
            o((a = a.apply(e, t)).next());
          });
      class ExchangerV2_ExchangerV2 {
        constructor() {
          l.a.once(c["WALLETS"].NEW_ATOMIC_ID, ({ atomicId: e }) => {
            const t = s.a.getUserAgentHttpHeader();
            this.http = r.a.create({
              baseURL: `${T}${v}`,
              headers: G(B({}, t), { [_]: e }),
            });
          });
        }
        makeHttpQuery(e, t, a) {
          return K(this, null, function* () {
            if (!this.http) throw new Error("No atomicId");
            const n = a,
              { forOperation: r } = n,
              i = W(n, ["forOperation"]);
            r && (i.get_for = r);
            const s = e === O.POST ? i : { params: i },
              { data: o } = yield this.http[e](t, s);
            return o;
          });
        }
        makeGet(e, t) {
          return K(this, null, function* () {
            const a = N(t);
            return this.makeHttpQuery(O.GET, e, a);
          });
        }
        makePost(e, t) {
          return K(this, null, function* () {
            return this.makeHttpQuery(O.POST, e, t);
          });
        }
        getAssets() {
          return K(this, arguments, function* (e = { forOperation: L.Buy }) {
            return this.makeGet(C, e);
          });
        }
        getFiats() {
          return K(this, arguments, function* (e = { forOperation: S.Buy }) {
            return this.makeGet(b, e);
          });
        }
        getMinMax(e) {
          return K(this, null, function* () {
            return this.makeGet(k, e);
          });
        }
        getEstimation(e) {
          return K(this, null, function* () {
            return this.makeGet(E, e);
          });
        }
        getTransaction(e) {
          return K(
            this,
            arguments,
            function* ({ provider: e, id: t, forOperation: a }) {
              return this.makeGet(`${A}/${e}/${t}`, { forOperation: a });
            },
          );
        }
        getTransactionList(e) {
          return K(this, null, function* () {
            return this.makeGet(A, e);
          });
        }
        getSubscription(e) {
          return K(this, arguments, function* ({ id: e }) {
            return this.makeGet(`${P}/${e}`);
          });
        }
        getSubscriptionList(e) {
          return K(this, null, function* () {
            return this.makeGet(P, e);
          });
        }
        createTransaction(e) {
          return K(this, null, function* () {
            return this.makePost(A, e);
          });
        }
        createSubscription(e) {
          return K(this, null, function* () {
            return this.makePost(P, e);
          });
        }
      }
      const j = new ExchangerV2_ExchangerV2();
    },
    1987: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.SOL_TOKEN_REQUEST_TYPE = void 0));
      t.SOL_TOKEN_REQUEST_TYPE = {
        NFTS_ONLY: "nftsOnly",
        TOKENS_ONLY: "tokensOnly",
      };
    },
    2014: function (e, t, a) {
      "use strict";
      (a.r(t),
        function (e) {
          (a.d(t, "GmgnApiClient", function () {
            return GmgnApiClient;
          }),
            a.d(t, "default", function () {
              return SwapInterface;
            }));
          var n = a(125),
            r = a(1),
            i = a(14),
            s = a.n(i),
            o = a(159),
            l = a.n(o),
            c = a(79),
            d = a(102),
            u = a.n(d),
            h = a(124),
            f = a.n(h),
            m = a(158),
            p = a(8),
            y = a.n(p),
            g = Object.defineProperty,
            w = Object.defineProperties,
            T = Object.getOwnPropertyDescriptors,
            v = Object.getOwnPropertySymbols,
            b = Object.prototype.hasOwnProperty,
            C = Object.prototype.propertyIsEnumerable,
            k = Math.pow,
            E = (e, t, a) =>
              t in e
                ? g(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: a,
                  })
                : (e[t] = a),
            A = (e, t) => {
              for (var a in t || (t = {})) b.call(t, a) && E(e, a, t[a]);
              if (v) for (var a of v(t)) C.call(t, a) && E(e, a, t[a]);
              return e;
            },
            P = (e, t) => w(e, T(t)),
            _ = (e, t, a) =>
              new Promise((n, r) => {
                var i = (e) => {
                    try {
                      o(a.next(e));
                    } catch (t) {
                      r(t);
                    }
                  },
                  s = (e) => {
                    try {
                      o(a.throw(e));
                    } catch (t) {
                      r(t);
                    }
                  },
                  o = (e) =>
                    e.done ? n(e.value) : Promise.resolve(e.value).then(i, s);
                o((a = a.apply(e, t)).next());
              });
          function S(e) {
            const t = parseFloat(e.inAmount) / k(10, e.inDecimals),
              a = parseFloat(e.outAmount) / k(10, e.outDecimals);
            return Number.isNaN(t) || Number.isNaN(a) || 0 === t
              ? "?"
              : (a / t).toFixed(e.outDecimals).replace(/\.0+$/, "");
          }
          function L(e) {
            const t = parseFloat(e.inAmount) / k(10, e.inDecimals),
              a = parseFloat(e.outAmount) / k(10, e.outDecimals);
            return Number.isNaN(t) || Number.isNaN(a) || 0 === t
              ? "?"
              : (a / t).toFixed(e.outDecimals).replace(/\.0+$/, "");
          }
          const N = "52C9T2T7JRojtxumYnYZhyUmrN7kqzvCLc4Ksvjk7TxD",
            O = 0,
            x = 55;
          class GmgnApiClient {
            constructor() {
              ((this.baseUrl = "https://gmgn.ai"),
                (this.apiClient = s.a.create({
                  baseURL: this.baseUrl,
                  headers: { "Content-Type": "application/json" },
                })));
            }
            getSwapRoute(e) {
              return _(this, null, function* () {
                const t = "/defi/router/v1/sol/tx/get_swap_route",
                  a = {
                    token_in_address: e.inputToken,
                    token_out_address: e.outputToken,
                    in_amount: e.amount,
                    from_address: e.fromAddress,
                    slippage: e.slippage.toString(),
                    swap_mode: e.swapMode,
                  };
                (e.fee && (a.fee = e.fee.toString()),
                  e.isAntiMev && (a.is_anti_mev = "true"),
                  e.partner && (a.partner = e.partner));
                const n = yield this.apiClient.get(t, { params: a });
                return n.data;
              });
            }
            submitSignedTransaction(e) {
              return _(this, null, function* () {
                const t = "/txproxy/v1/send_transaction",
                  a = yield this.apiClient.post(t, {
                    chain: "sol",
                    signedTx: e,
                  });
                if (a.data.code !== O)
                  throw new Error(JSON.stringify(a.data.data));
                return a.data;
              });
            }
            getTransactionStatus(e) {
              return _(this, null, function* () {
                const t = "/defi/router/v1/sol/tx/get_transaction_status",
                  a = yield this.apiClient.get(t, { params: { hash: e } });
                return a.data;
              });
            }
          }
          class SwapInterface {
            constructor(e = new GmgnApiClient(), t, a, n) {
              var r, i;
              if (((this.client = e), !this.client))
                throw new Error(
                  "MemeSwap contructor: GmgnApiClient instance not provided",
                );
              if (
                ((this.solana =
                  null !=
                  (i =
                    null != t
                      ? t
                      : null == (r = f.a)
                        ? void 0
                        : r.getWallet("SOL"))
                    ? i
                    : null == n
                      ? void 0
                      : n.getWallet("SOL")),
                !this.solana)
              )
                throw new Error(
                  "MemeSwap contructor: Solana instance not provided",
                );
              if (((this.rates = null != a ? a : u.a), !this.rates))
                throw new Error(
                  "MemeSwap contructor: Rates instance not provided",
                );
              ((this.transferFee = 5e-6 * k(10, this.solana.decimal)),
                (this.swapFee = 1e-4 * k(10, this.solana.decimal)),
                (this.platformFee = 0.003 * k(10, this.solana.decimal)),
                (this.accountCreationFee = 0.002 * k(10, this.solana.decimal)));
            }
            getEstimate(e) {
              return _(this, null, function* () {
                var t;
                const a = ["0", "", null, void 0].some(
                    (t) => t === e.sendAmountCurrencyUnit,
                  ),
                  n = "SOL" === e.sendCoin.id,
                  r = a && n,
                  i =
                    null != (t = e.sendAmountMinimalUnit)
                      ? t
                      : yield e.sendCoin.toMinimalUnit(
                          r ? "0.1" : e.sendAmountCurrencyUnit,
                        ),
                  s = "ExactIn",
                  o = !1,
                  l = "81413442";
                try {
                  const t = yield this.client.getSwapRoute({
                    inputToken: e.sendCoin.mint,
                    outputToken: e.receiveCoin.mint,
                    amount: i,
                    fromAddress: r ? N : this.solana.address,
                    slippage: x,
                    swapMode: s,
                    fee: this.swapFee / k(10, this.solana.decimal),
                    isAntiMev: o,
                    partner: l,
                  });
                  if (t.code) throw new Error(t.msg);
                  const a =
                      this.transferFee +
                      this.swapFee +
                      this.accountCreationFee +
                      Number(t.data.quote.platformFee),
                    n = {
                      sendCoin: e.sendCoin,
                      receiveCoin: e.receiveCoin,
                      feeCoin: this.solana,
                      send: e.sendAmountCurrencyUnit,
                      sendUSD: t.data.amount_in_usd,
                      sendMinimal: i,
                      receive: e.receiveCoin.toCurrencyUnit(
                        t.data.quote.outAmount,
                      ),
                      receiveUSD: t.data.amount_out_usd,
                      receiveMinimal: t.data.quote.outAmount,
                      fee: this.solana.toCurrencyUnit(a.toString()).toString(),
                      feeUSD: this.rates
                        .convertToUSD(
                          this.solana.toCurrencyUnit(a.toString()).toString(),
                          { id: "SOL", confirmed: !0 },
                          "USD",
                        )
                        .toFixed(2),
                      feeMinimal: a.toString(),
                      minimumReceived: e.receiveCoin
                        .toCurrencyUnit(t.data.quote.otherAmountThreshold)
                        .toString(),
                      receivePerOneSend: S(t.data.quote),
                      receivePerOneSol: L(t.data.quote),
                    };
                  return { estimateParams: e, estimateResponse: t, quote: n };
                } catch (c) {
                  return (
                    console.error("SwapInterface: estimate error:", c),
                    null
                  );
                }
              });
            }
            swap(e, t) {
              return _(this, null, function* () {
                var a, n, r, i, s;
                if (!(null == e ? void 0 : e.estimateResponse))
                  throw new Error("No estimate");
                const o = this.solana.getProvider(m["NODE_PROVIDER_OPERATION"]),
                  l = yield this.swapImpl(
                    e.estimateResponse.data.raw_tx.swapTransaction,
                    e.estimateResponse.data.quote,
                    o,
                  );
                if (!l) throw new Error("No signedTx");
                const { txid: d } = yield o.sendRawTransactionToJito(l, !1),
                  u = e.estimateParams.sendCoin,
                  h = e.estimateParams.receiveCoin,
                  f = {
                    txid: d,
                    timestamp: Date.now(),
                    from: {
                      id: u.id,
                      contract: "SOL" !== u.id ? u.mint : "SOL",
                      amount:
                        null !=
                        (n = null == (a = e.quote) ? void 0 : a.sendMinimal)
                          ? n
                          : "0",
                      imgUri: "SOL" !== u.id ? t : null,
                    },
                    to: {
                      id: h.id,
                      contract:
                        "SOL" !== h.id ? (null == h ? void 0 : h.mint) : "SOL",
                      amount:
                        null !=
                        (i = null == (r = e.quote) ? void 0 : r.receiveMinimal)
                          ? i
                          : "0",
                      imgUri: "SOL" !== h.id ? t : null,
                    },
                    status: "unconfirmed",
                    fee: Number(null == (s = e.quote) ? void 0 : s.fee),
                    feeTicker: "SOL",
                  };
                c["memesHistory"].put(f);
                const p = yield this.checkHistoryAndBalance(d, u, h);
                if ("failed" !== p) return { txid: d };
                throw new Error(`MemeSwap: tx "${d}" failed`);
              });
            }
            checkHistoryAndBalance(e, t, a) {
              return _(this, null, function* () {
                for (let r = 0; r < 5; r++)
                  try {
                    const { data: n } =
                      yield this.client.getTransactionStatus(e);
                    if (n.success)
                      return (
                        this.runUpdateLoop(e, t, a),
                        yield c["memesHistory"].updateStatus(e, "confirmed"),
                        "confirmed"
                      );
                    if (n.failed)
                      return (
                        yield c["memesHistory"].updateStatus(e, "failed"),
                        "failed"
                      );
                    yield new Promise((e) => setTimeout(e, 5e3));
                  } catch (n) {
                    console.error(
                      "SwapInterface: check history and balance error:",
                      n,
                    );
                  }
                return "unconfirmed";
              });
            }
            updateBalancesForTokenAndSol(e, t) {
              return Promise.all([e.getInfo(), t.getInfo()]);
            }
            runUpdateLoop(e, t, a) {
              return _(this, null, function* () {
                for (let n = 0; n < 5; n++) {
                  const n = yield this.solana.getSwapTransaction(e, t, a);
                  if (n)
                    return (
                      this.solana.getInfo(),
                      this.solana.initTokenBalances(),
                      void (yield c["memesHistory"].updateToAmount(
                        e,
                        n.to.amount,
                      ))
                    );
                  yield new Promise((e) => setTimeout(e, 5e3));
                }
              });
            }
            getFee() {
              return _(this, null, function* () {
                return (
                  this.swapFee +
                  this.platformFee +
                  this.transferFee +
                  this.accountCreationFee
                );
              });
            }
            swapImpl(t, a, n) {
              return _(this, null, function* () {
                const i = r["Keypair"].fromSecretKey(
                    this.solana.getPrivateKey(),
                  ),
                  s = e.from(t, "base64"),
                  o = r["VersionedTransaction"].deserialize(s),
                  l = o.message.addressTableLookups.map((e) => e.accountKey),
                  c = yield n.getMultipleAccountsInfo(l),
                  d = c.map((t, a) => {
                    var n;
                    const i = o.message.addressTableLookups[a];
                    return new r["AddressLookupTableAccount"]({
                      key: i.accountKey,
                      state: r["AddressLookupTableAccount"].deserialize(
                        null != (n = null == t ? void 0 : t.data)
                          ? n
                          : e.from([]),
                      ),
                    });
                  });
                if (a) {
                  const e = yield this.validateTransactionSafety(t, o, d, a, n);
                  if (!e)
                    return (
                      console.error("❌ Transaction failed safety check"),
                      null
                    );
                }
                const {
                    inputMint: u,
                    outputMint: h,
                    inAmount: f,
                    outAmount: m,
                  } = a,
                  p = [u, h].includes(this.solana.mint)
                    ? this.calcSwapFee(u === this.solana.mint ? f : m)
                    : 0,
                  y = yield this.createNewTxWithFee(o, d, BigInt(p));
                y.sign([i]);
                const g = e.from(y.serialize());
                return g;
              });
            }
            createNewTxWithFee(e, t, a) {
              return _(this, null, function* () {
                const n = yield y.a.get(p["ConfigKey"].Memes),
                  i = Object(c["validateMemesConfig"])(n),
                  s = i.feeReceiverPublicKey,
                  o = i.gmgnVaultFeePublicKey;
                if (!o && (!s || !a)) return e;
                const l = this.solana.getProvider(m["NODE_PROVIDER_OPERATION"]),
                  d = r["TransactionMessage"].decompile(e.message, {
                    addressLookupTableAccounts: t,
                  }).instructions,
                  u = [];
                if (o) {
                  const e = new r["PublicKey"](o),
                    t = d.filter((t) => {
                      if (t.programId.equals(r["SystemProgram"].programId)) {
                        const a =
                          r["SystemInstruction"].decodeInstructionType(t);
                        if ("Transfer" === a) {
                          const a = r["SystemInstruction"].decodeTransfer(t);
                          return !a.toPubkey.equals(e);
                        }
                      }
                      return !0;
                    });
                  u.push(...t);
                } else u.push(...d);
                const { blockhash: h } = yield l.getLatestBlock();
                if (s && a) {
                  const e = r["SystemProgram"].transfer({
                    fromPubkey: new r["PublicKey"](this.solana.address),
                    toPubkey: new r["PublicKey"](s),
                    lamports: a,
                  });
                  u.push(e);
                }
                const f = new r["TransactionMessage"]({
                  payerKey: new r["PublicKey"](this.solana.address),
                  recentBlockhash: h,
                  instructions: u,
                }).compileToV0Message(t);
                return new r["VersionedTransaction"](f);
              });
            }
            calcSwapFee(e) {
              const t = l()(0.005);
              let a;
              if (((e = l()(e).div(r["LAMPORTS_PER_SOL"])), e.lte(0.1))) a = t;
              else if (e.lte(2)) {
                const n = l()(0.02).div(1.9).mul(e.minus(0.1));
                a = t.add(e.mul(n));
              } else a = t.add(e.mul(0.02));
              return a.mul(r["LAMPORTS_PER_SOL"]).toFixed(0).toString();
            }
            validateTransactionSafety(t, a, i, s, o) {
              return _(this, null, function* () {
                var l, c, d, u, h, f, m, p;
                const y = this.solana.BN,
                  g = new r["PublicKey"](this.solana.address),
                  [w, T] =
                    (o.findTokenProgramId(s.outputMint),
                    [s.inputMint, s.outputMint].map((e) =>
                      e === this.solana.mint
                        ? g
                        : Object(n["getAssociatedTokenAddressSync"])(
                            new r["PublicKey"](e),
                            g,
                            !1,
                            o.findTokenProgramId(e),
                          ),
                    )),
                  v = yield o.getParsedTokenAccountsByOwner({ owner: g }),
                  b = v.map((e) => e.pubkey.toBase58()),
                  C = [w.toBase58(), T.toBase58()],
                  k = {
                    commitment: "processed",
                    replaceRecentBlockhash: !0,
                    sigVerify: !1,
                    accounts: { encoding: "base64", addresses: C },
                  },
                  E = yield o.simulateTransaction(t, k);
                if (!E.success || !E.simulation || E.simulation.err)
                  return (
                    console.error(
                      "Transaction is not valid",
                      null == (l = E.simulation) ? void 0 : l.logs,
                    ),
                    !1
                  );
                const _ =
                  null == (c = E.simulation.accounts)
                    ? void 0
                    : c.filter((e, t) => !!e && ((e.address = C[t]), !0));
                if (!_ || (null == _ ? void 0 : _.length) < 2)
                  return (
                    console.error("Simulation result accounts not enough."),
                    !1
                  );
                const [S, L] = _.map((t) =>
                  P(A({}, t), {
                    owner: new r["PublicKey"](t.owner),
                    data: e.from(t.data[0], t.data[1]),
                  }),
                );
                if (!S || !L)
                  return (
                    console.error(
                      "Simulation result accounts are not defined.",
                    ),
                    !1
                  );
                const N = new y(s.inAmount),
                  O = new y(r["LAMPORTS_PER_SOL"] / 10);
                if (S.address !== this.solana.address) {
                  const e = new y(
                      null !=
                        (d = yield o.getTokenBalance({ address: S.address }))
                        ? d
                        : 0,
                    ),
                    t =
                      S.data.byteLength > 0
                        ? new y(
                            Object(n["unpackAccount"])(
                              new r["PublicKey"](S.address),
                              S,
                              o.findTokenProgramId(s.inputMint),
                            ).amount,
                          )
                        : new y(0);
                  if (!t)
                    return (
                      console.error("Input account balance after is not valid"),
                      !1
                    );
                  const a = e.sub(t);
                  if (N.sub(a).isNeg())
                    return (console.error("spent higher than expected"), !1);
                } else {
                  const e = new y(
                      null !=
                        (h =
                          null == (u = yield o.getInfo(g)) ? void 0 : u.balance)
                        ? h
                        : 0,
                    ),
                    t = new y(S.lamports),
                    a = e.sub(t);
                  if (N.sub(a).add(O).isNeg())
                    return (
                      console.error("spent higher than inputAmount + maxLoss"),
                      !1
                    );
                }
                const x = new y(s.outAmount),
                  I = Math.min(s.slippageBps, 500),
                  R = x.sub(x.mul(new y(I)).div(new y(1e4)));
                if (L.address !== this.solana.address) {
                  const e = new y(
                      null !=
                        (f = yield o.getTokenBalance({ address: L.address }))
                        ? f
                        : 0,
                    ),
                    t =
                      L.data.byteLength > 0
                        ? new y(
                            Object(n["unpackAccount"])(
                              new r["PublicKey"](L.address),
                              L,
                              o.findTokenProgramId(s.outputMint),
                            ).amount,
                          )
                        : new y(0);
                  if (!t)
                    return (
                      console.error(
                        "Output account balance after is not valid",
                      ),
                      !1
                    );
                  const a = t.sub(e);
                  if (a.sub(R).isNeg())
                    return (console.error("received lower than expected"), !1);
                } else {
                  const e = new y(
                      null !=
                        (p =
                          null == (m = yield o.getInfo(g)) ? void 0 : m.balance)
                        ? p
                        : 0,
                    ),
                    t = new y(L.lamports),
                    a = t.sub(e);
                  if (a.sub(R).add(O).isNeg())
                    return (
                      console.error("received lower than expected + maxLoss"),
                      !1
                    );
                }
                const D = b.filter(
                    (e) => !(e === S.address || e === L.address),
                  ),
                  M = new Set(
                    a.message
                      .getAccountKeys({ addressLookupTableAccounts: i })
                      .keySegments()
                      .reduce((e, t) => e.concat(t), [])
                      .map((e) => e.toBase58()),
                  );
                return (
                  !D.some((e) => M.has(e)) ||
                  (console.error(
                    "Transaction uses third ATA:",
                    D.filter((e) => M.has(e)),
                  ),
                  !1)
                );
              });
            }
          }
        }.call(this, a(2).Buffer));
    },
    2017: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class DeprecatedStaking {
        constructor(e) {
          ((this.name = e), (this.validators = []));
        }
        getName() {
          return this.name;
        }
        getValidator(e) {
          return this.validators.find((t) => t.name === e || t.address === e);
        }
        async fetchActiveValidators(e) {}
        modifyPredefinedValidators(e) {
          ((this.validators = e), this.fetchActiveValidators());
        }
        modifyActiveValidators(e) {
          throw new Error("Undeclared method `modifyActiveValidators", this);
        }
      }
      t.default = DeprecatedStaking;
    },
    2023: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(14)),
        i = o(a(8)),
        s = n(a(2024));
      function o(e, t) {
        if ("function" == typeof WeakMap)
          var a = new WeakMap(),
            n = new WeakMap();
        return (o = function (e, t) {
          if (!t && e && e.__esModule) return e;
          var r,
            i,
            s = { __proto__: null, default: e };
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return s;
          if ((r = t ? n : a)) {
            if (r.has(e)) return r.get(e);
            r.set(e, s);
          }
          for (const a in e)
            "default" !== a &&
              {}.hasOwnProperty.call(e, a) &&
              ((i =
                (r = Object.defineProperty) &&
                Object.getOwnPropertyDescriptor(e, a)) &&
              (i.get || i.set)
                ? r(s, a, i)
                : (s[a] = e[a]));
          return s;
        })(e, t);
      }
      class ChangeNowV2ApiClient {
        constructor() {
          ((this.apiKey = s.default.apiKey),
            (this.baseUrl = "https://move-api.atomicwallet.io/v2/move"),
            this.loadApiKey());
        }
        async loadApiKey() {
          const { apiKey: e } = await i.default.get(
            i.ConfigKey.ChangeNowSettings,
          );
          this.apiKey = e;
        }
        queryGet(e, t) {
          return (void 0 === t && (t = {}), this.query("get", e, t));
        }
        queryPost(e, t) {
          return (void 0 === t && (t = {}), this.query("post", e, t));
        }
        async query(e, t, a) {
          void 0 === a && (a = {});
          try {
            await this.loadApiKey();
          } catch (n) {
            console.error(n);
          }
          try {
            const { data: n } = await (0, r.default)({
              method: e,
              url: `${this.baseUrl}/${t}`,
              ["post" === e ? "data" : "params"]: a,
              headers: { "x-changenow-api-key": this.apiKey },
            });
            return n;
          } catch (n) {
            throw new Error("Can't connect to ChangeNOW");
          }
        }
      }
      t.default = ChangeNowV2ApiClient;
    },
    2024: function (e) {
      e.exports = JSON.parse(
        '{"apiKey":"7cd76888ccee2317b76dab909e1b36f0d70aa7fc13d8866eeace933dfc7f4544"}',
      );
    },
    2025: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(69)),
        i = a(333);
      class WalletConverter {
        constructor(e) {
          ((0, r.default)(this, "deprecatedParentMap", {
            ETHARB: "arbitrum",
            ETHOP: "op",
            OP: "op",
            arbitrum: "arbitrum",
            ARB: "arbitrum",
            BSC: "bsc",
            NANO: "nano",
          }),
            (this.apiClient = e),
            (this.availableTargetCoinsPromise = null));
        }
        getDeterministicFieldSet(e) {
          void 0 === e && (e = {});
          const {
              contract: t,
              network: a,
              deprecatedParent: n,
              ticker: r,
              isL2: s,
            } = e,
            o = "string" !== typeof a || ["", "mainnet"].includes(a) ? n : a,
            l = { ong: "ont" },
            c = {
              deprecatedParent: l[o.toLowerCase()] || o,
              contract: t,
              ticker: r,
              isL2: s,
            };
          for (const [d, u] of Object.entries(i.TICKER_MAPPING)) {
            const [e, i, s] = d.split("|");
            if (
              r === u &&
              (e === n.toLowerCase() || "arbitrum" === a) &&
              (null !== t && void 0 !== t ? t : "") === s
            ) {
              c.ticker = i.toUpperCase();
              break;
            }
          }
          return c;
        }
        async getTarget(e) {
          const {
            contract: t,
            deprecatedParent: a,
            ticker: n,
            isL2: r,
          } = this.getDeterministicFieldSet(e);
          return (
            this.isInitialized() || this.initialize(),
            (await this.availableTargetCoinsPromise).find((e) => {
              let { network: i, ticker: s, tokenContract: o } = e;
              const l =
                  ((!t && !o) || this.isContractIgnored(a, n)) &&
                  n.toLowerCase() === s.toLowerCase(),
                c =
                  void 0 !== t &&
                  null !== o &&
                  t.toLowerCase() === o.toLowerCase(),
                d =
                  this.deprecatedParentMap[a] ||
                  (r ? a : (t ? a : n).toLowerCase());
              return d === i.toLowerCase() && (l || c);
            })
          );
        }
        initialize() {
          this.availableTargetCoinsPromise =
            this.apiClient.queryGet("currencies");
        }
        isInitialized() {
          return null !== this.availableTargetCoinsPromise;
        }
        isContractIgnored(e, t) {
          return (
            ("ont" === e.toLowerCase() && "ong" === t.toLowerCase()) ||
            "baby" === e.toLowerCase()
          );
        }
      }
      t.default = WalletConverter;
    },
    2026: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = a(19),
        i = n(a(2027));
      class Exchanger {
        constructor(e) {
          this.client = this.createExchangeClient(e);
        }
        createExchangeClient(e) {
          throw new r.UndeclaredAbstractMethodError(
            "createExchangeClient",
            this,
          );
        }
        fetchAvailableTickers() {
          throw new r.UndeclaredAbstractMethodError(
            "fetchAvailableTickers",
            this,
          );
        }
        getAvailableWallets() {
          throw new r.UndeclaredAbstractMethodError(
            "getAvailableWallets",
            this,
          );
        }
        async getExchangeRate() {
          throw new r.UndeclaredAbstractMethodError("getExchangeRate", this);
        }
        getMinAndMaxAmount(e, t) {
          throw new r.UndeclaredAbstractMethodError("getMinAndMaxAmount", this);
        }
        createExchangeTransaction(e) {
          return new i.default(e);
        }
        validateExchangeTx(e) {
          throw new r.UndeclaredAbstractMethodError("validateExchangeTx", this);
        }
        async makeExchange(e) {
          throw new r.UndeclaredAbstractMethodError("makeExchange", this);
        }
        getExchangeTransactions(e) {
          throw new r.UndeclaredAbstractMethodError(
            "getExchangeTransactions",
            this,
          );
        }
        getExchangeTransaction(e) {
          throw new r.UndeclaredAbstractMethodError(
            "getExchangeTransaction",
            this,
          );
        }
      }
      t.default = Exchanger;
    },
    2028: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(14));
      function i(e, t, a) {
        (s(e, t), t.set(e, a));
      }
      function s(e, t) {
        if (t.has(e))
          throw new TypeError(
            "Cannot initialize the same private elements twice on an object",
          );
      }
      function o(e, t) {
        return e.get(c(e, t));
      }
      function l(e, t, a) {
        return (e.set(c(e, t), a), a);
      }
      function c(e, t, a) {
        if ("function" == typeof e ? e === t : e.has(t))
          return arguments.length < 3 ? t : a;
        throw new TypeError("Private element is not present on this object");
      }
      const d = "simplex",
        u = "simplexPay",
        h = "simplexSubmit",
        f = "simplexEvent",
        m = "supportedContries",
        p = "supportedCryptoCurrencies",
        y = "supportedFiatCurrencies",
        g = "GET",
        w = "POST";
      var T = new WeakMap();
      class ApiClient {
        constructor(e) {
          (i(this, T, void 0), l(T, this, r.default.create({ baseURL: e })));
        }
        createV2Payload(e, t) {
          return { method: g, url: e, data: { paymentMethod: t } };
        }
        async getQuote(e, t) {
          const a = { method: w, url: d, data: e };
          return { response: await o(T, this).call(this, a), token: t };
        }
        requestPayment(e) {
          const t = { method: w, url: u, data: e };
          return o(T, this).call(this, t);
        }
        submitPayment(e) {
          const t = { method: w, url: h, data: e };
          return o(T, this).call(this, t);
        }
        getEvents(e) {
          const t = { method: g, url: `${f}/${e}` };
          return o(T, this).call(this, t);
        }
        getSupportedCountries(e) {
          const t = this.createV2Payload(m, e);
          return o(T, this).call(this, t);
        }
        getSupportedCurrencies(e) {
          const t = this.createV2Payload(p, e);
          return o(T, this).call(this, t);
        }
        getSupportedFiat(e) {
          const t = this.createV2Payload(y, e);
          return o(T, this).call(this, t);
        }
      }
      t.default = ApiClient;
    },
    241: function (e, t, a) {
      "use strict";
      (function (e) {
        var n = a(0);
        (Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0));
        var r = n(a(69)),
          i = n(a(230)),
          s = a(805),
          o = n(a(28)),
          l = n(a(8)),
          c = n(a(823)),
          d = a(19),
          u = a(27),
          h = a(74),
          f = n(a(80)),
          m = n(a(794)),
          p = n(a(1875)),
          y = n(a(397)),
          g = n(a(815)),
          w = n(a(853)),
          T = n(a(846)),
          v = n(a(880)),
          b = n(a(881)),
          C = n(a(158)),
          k = n(a(382)),
          E = n(a(386));
        function A(e, t) {
          (_(e, t), t.add(e));
        }
        function P(e, t, a) {
          (_(e, t), t.set(e, a));
        }
        function _(e, t) {
          if (t.has(e))
            throw new TypeError(
              "Cannot initialize the same private elements twice on an object",
            );
        }
        function S(e, t, a) {
          return a(O(e, t));
        }
        function L(e, t) {
          return e.get(O(e, t));
        }
        function N(e, t, a) {
          return (e.set(O(e, t), a), a);
        }
        function O(e, t, a) {
          if ("function" == typeof e ? e === t : e.has(t))
            return arguments.length < 3 ? t : a;
          throw new TypeError("Private element is not present on this object");
        }
        const x = 18,
          I = 21e3,
          R = 0,
          D = 1e4,
          M = 1e9,
          F = "0x",
          U = "0x29625E10Cfe090294DC0eC579E322ce87C822745",
          B = "0x420000000000000000000000000000000000000F",
          G = 15e4,
          W = "pending",
          K = "0x0",
          j = "node",
          q = "balance",
          V = "history",
          $ = "token",
          H = "token-history",
          Y = "tokens-list-history",
          Q = "send",
          z = "nft-send",
          J = "socket",
          X = "insufficient funds",
          Z = "web3Sdk",
          ee = "ethereumJsWalletSdk",
          te = 5e3,
          ae = 400;
        var ne = new WeakMap(),
          re = new WeakMap(),
          ie = new WeakMap(),
          se = new WeakMap(),
          oe = new WeakMap(),
          le = new WeakSet();
        class EVMCoin extends (0, p.default)(
          (0, y.default)(
            (0, E.default)(
              (0, c.default)((0, C.default)((0, k.default)(i.default))),
            ),
          ),
        ) {
          constructor(e) {
            var t, n;
            const {
              id: i,
              isL2: s,
              isUseModeratedGasPrice: o = !1,
              isUseEIP1559: c = !1,
              feeData: d,
              explorers: u,
            } = e;
            let h, f;
            switch (
              (super({
                ...e,
                decimal: x,
                l2Name: s ? i : null,
                unspendableBalance: d.unspendableBalance,
                dependencies: {
                  [Z]: new m.default(() =>
                    Promise.all([
                      a.e(0),
                      a.e(7),
                      a.e(8),
                      a.e(10),
                      a.e(14),
                      a.e(13),
                      a.e(12),
                      a.e(11),
                      a.e(32),
                    ]).then(a.t.bind(null, 2654, 7)),
                  ),
                  [ee]: new m.default(() =>
                    Promise.all([a.e(0), a.e(26)]).then(
                      a.t.bind(null, 2655, 7),
                    ),
                  ),
                },
              }),
              A(this, le),
              P(this, ne, void 0),
              P(this, re, void 0),
              P(this, ie, void 0),
              P(this, se, void 0),
              P(this, oe, void 0),
              (0, r.default)(this, "web3BaseUrl", void 0),
              (0, r.default)(this, "coreLibrary", null),
              this.setExplorersModules([
                g.default,
                w.default,
                T.default,
                v.default,
              ]),
              this.loadExplorers(e),
              null !== (t = e.features) &&
                void 0 !== t &&
                t.includes("liquid-staking") &&
                this.createPool(),
              this.setFeeData(d),
              (this.isL2 = s),
              (this.tokens = {}),
              (this.bannedTokens = []),
              (this.nonce = new this.BN("0")),
              (this.fields.paymentId = !1),
              i)
            ) {
              case "ARB":
                f = "arbitrum";
                break;
              case "AVAX":
                h = "avax-c";
                break;
              case "ETH":
                f = "ethereum";
                break;
              case "LUNC":
                f = "luna-classic";
                break;
              case "FLR":
                f = "flare";
                break;
              case "FTM":
                f = "fantom";
                break;
              case "OP":
                f = "optimism";
                break;
              case "MATIC":
                ((h = "polygon"), (f = "polygon"));
                break;
              default:
                ((h = i.toLowerCase()), (f = i.toLowerCase()));
            }
            (N(oe, this, c),
              N(re, this, o ? h + "-gas-price" : null),
              N(ie, this, f + "-tokens"),
              N(se, this, f + "-tokens-banned"),
              L(re, this) && l.default.register(L(re, this), { cacheTtl: D }),
              L(ie, this) && l.default.register(L(ie, this)),
              L(se, this) && l.default.register(L(se, this)),
              (this.web3BaseUrl =
                null ===
                  (n = u.find((e) => {
                    let { className: t } = e;
                    return "Web3Explorer" === t;
                  })) || void 0 === n
                  ? void 0
                  : n.baseUrl),
              this.eventEmitter.on(
                this.ticker + "::confirmed-socket-tx",
                (e, t, a) => {
                  this.eventEmitter.emit("socket::tx::confirmed", {
                    id: e,
                    ticker: a,
                  });
                },
              ));
          }
          async initCoreLibrary() {
            if (this.coreLibrary) return;
            const { default: e } = await this.loadLib(Z);
            this.coreLibrary = new e(this.web3BaseUrl);
          }
          async getCoreLibrary() {
            return (
              this.coreLibrary || (await this.initCoreLibrary()),
              this.coreLibrary
            );
          }
          get networkType() {
            return "EVM";
          }
          get isCustomTokenSupported() {
            return !0;
          }
          setFeeData(e) {
            (void 0 === e && (e = {}),
              super.setFeeData(e),
              (this.defaultGasPrice = Number(e.defaultGasPrice) || 1),
              (this.defaultMaxGasPrice = Number(e.defaultMaxGasPrice) || 100),
              (this.gasPriceCoefficient = Number(e.gasPriceCoefficient) || 0),
              (this.nftGasPriceCoefficient = Number(e.nftGasPriceCoefficient)),
              (this.gasLimit = Number(e.gasLimit) || I),
              (this.maxGasLimit = Number(e.maxGasLimit) || G),
              (this.gasLimitCoefficient = Number(e.gasLimitCoefficient) || 1),
              (this.contractGasLimitCoefficient =
                Number(e.contractGasLimitCoefficient) || 5),
              (this.nftGasLimitCoefficient =
                Number(e.nftGasLimitCoefficient) || 1),
              (this.resendTimeout = e.resendTimeout),
              (this.unspendableBalance = e.unspendableBalance || R),
              (this.maxGasLimitL1 = Number(e.maxGasLimitL1) || te),
              (this.maxGasPriceL1 = Number(e.maxGasPriceL1) || ae));
          }
          isFeeDynamic() {
            return !0;
          }
          getTokenTransactions(e) {
            let { contract: t } = e;
            if (!t)
              throw new Error(
                this.ticker + ": `contract` parameter should be defined",
              );
            return this.getProvider(H).getTokenTransactions({
              address: this.address,
              contract: t,
            });
          }
          async getTransactions() {
            var e, t, a, n;
            if (!this.address)
              throw new Error(
                this.id + ": getTransactions: address is not loaded",
              );
            const r = this.getProvider(V),
              i = this.getProvider(Y),
              [s = [], { rawTokenTransactions: o = [] }] = await Promise.all(
                [
                  null !==
                    (e =
                      null === r ||
                      void 0 === r ||
                      null === (t = r.getTransactions) ||
                      void 0 === t
                        ? void 0
                        : t.call(r, { address: this.address })) && void 0 !== e
                    ? e
                    : Promise.resolve([]),
                  null !==
                    (a =
                      null === i ||
                      void 0 === i ||
                      null === (n = i.getTokensTransactions) ||
                      void 0 === n
                        ? void 0
                        : n.call(i, { address: this.address })) && void 0 !== a
                    ? a
                    : Promise.resolve({}),
                ].map((e) => e.catch((e) => (console.error(e), []))),
              ),
              l = o.reduce((e, t) => {
                const a = t.contract.toLowerCase(),
                  n = this.tokens[a];
                return (
                  e.push(new f.default({ ...t, amount: n ? t.amount : null })),
                  e
                );
              }, []);
            return s.concat(l);
          }
          manageSocket() {
            (this.eventEmitter.on("receive", async (e) => {
              let { address: t, hash: a, ticker: n } = e;
              this.ticker === n &&
                this.getProvider(J).getSocketTransaction({
                  address: t,
                  hash: a,
                  tokens: this.tokens,
                  type: "receive",
                });
            }),
              this.eventEmitter.on("confirm", async (e) => {
                let { address: t, hash: a, ticker: n } = e;
                this.ticker === n &&
                  this.getProvider(J).getSocketTransaction({
                    address: t,
                    hash: a,
                    tokens: this.tokens,
                    type: "confirm",
                  });
              }));
          }
          getExcludedTokenList() {
            return ["TRX", "EOS", "ICX", "VEN", "AION", "BTT", "KIN", "BNB"]
              .concat(Array.isArray(this.bannedTokens) ? this.bannedTokens : [])
              .map((e) => e.toLowerCase());
          }
          async loadWallet(e, t) {
            const [a, { hdkey: n }] = await Promise.all([
                this.getCoreLibrary(),
                this.loadLib(ee),
              ]),
              r = n.fromMasterSeed(e),
              i = r.getWallet(),
              s = await a.eth.accounts.privateKeyToAccount(
                i.getPrivateKeyString(),
              );
            if (!s) throw new Error(this.id + " cant get a wallet!");
            return (
              await this.setPrivateKey(s.privateKey),
              { id: this.id, privateKey: L(ne, this), address: this.address }
            );
          }
          async validateAddress(e) {
            const t = await this.getCoreLibrary();
            return t.utils.isAddress(e);
          }
          async createTransaction(e) {
            let {
              address: t,
              isSendAll: a = !1,
              userFee: n = null,
              amount: r,
              nonce: i,
              userGasPrice: s,
              multiplier: o,
              gasLimit: l,
              paymentData: c = null,
            } = e;
            const d = l || (await this.estimateGas(r, t)) || this.gasLimit,
              u = s || (await this.getGasPrice(!0)),
              h = {
                gas: d,
                to: t,
                value: r,
                nonce: i || (await this.getNonce()),
              };
            if (L(oe, this)) {
              const e = new this.BN(u),
                t = e.divn(10),
                a = e.add(t);
              ((h.maxPriorityFeePerGas = t.toString()),
                (h.maxFeePerGas = a.toString()),
                (h.type = "0x2"));
            } else h.gasPrice = u;
            "" !== c && null !== c && (h.data = c);
            const f = await this.getCoreLibrary(),
              m = await f.eth.accounts.signTransaction(h, L(ne, this));
            return m.rawTransaction;
          }
          async createTokenTransaction(e) {
            let {
              address: t,
              amount: a,
              custom: n,
              userGasPrice: r,
              gasLimit: i,
              contract: s,
              multiplier: o,
            } = e;
            const l = O(le, this, ce).call(this, s, t, a);
            return this.createTransaction({
              address: s,
              amount: K,
              paymentData: l,
              userGasPrice: r,
              gasLimit: i || (await this.estimateGas(a, t, s)),
              multiplier: o,
            });
          }
          sendTransaction(e) {
            const t = this.getProvider(Q).sendTransaction(e);
            return (t && (this.nonce = this.nonce.add(new this.BN(1))), t);
          }
          async getGasPriceForSendNft(e) {
            const t = await this.getGasPrice(!0),
              a = Number(t) + e * M,
              n = this.defaultMaxGasPrice * M;
            return a > n ? n : a;
          }
          async estimateGasForSendNft(e, t, a, n) {
            void 0 === n && (n = 1);
            const r = { from: e, to: t, value: K, data: a },
              i = await this.getCoreLibrary(),
              s = await i.eth
                .estimateGas(r)
                .catch(
                  (e) => (
                    e.message.includes(X) ||
                      o.default.error({ instance: this, error: e }),
                    this.maxGasLimit
                  ),
                );
            return Math.ceil(s * this.nftGasLimitCoefficient);
          }
          async getNftTransferGasParams(e, t, a) {
            let { userGasPrice: n, userGasLimit: r } = a;
            const {
                address: i,
                nftGasPriceCoefficient: s,
                nftGasLimitCoefficient: o,
                gasPriceCoefficient: l,
                gasLimitCoefficient: c,
                defaultGasPrice: d,
                gasLimit: u = G,
              } = this,
              h = s || l,
              f = o || c,
              m = [(d + h) * M, Math.ceil(u * f)],
              p = (await this.getNonce()).toNumber(),
              [y, g] = await Promise.allSettled([
                n || this.getGasPriceForSendNft(h),
                r || this.estimateGasForSendNft(i, e, t, f),
              ]).then((e) =>
                e.map((e, t) => ("fulfilled" === e.status ? e.value : m[t])),
              );
            return { gasLimit: g, gasPrice: y, nonce: p };
          }
          async getNftFee(e) {
            let {
              contractAddress: t,
              tokenId: a,
              tokenStandard: n,
              toAddress: r = null,
              userOptions: i = {},
            } = e;
            const s =
              r && r.toLowerCase() !== this.address.toLowerCase() ? r : U;
            try {
              const e = await this.getProvider(z).getNftContractData(
                  this,
                  s,
                  t,
                  a,
                  n,
                ),
                { gasLimit: r, gasPrice: o } =
                  await this.getNftTransferGasParams(t, e, i);
              return new this.BN(o).mul(new this.BN(r));
            } catch (o) {
              throw new d.ExternalError({
                type: u.EXTERNAL_ERROR,
                error: o,
                instance: this,
              });
            }
          }
          async createNftTransaction(e) {
            let { contractAddress: t, data: a, userOptions: n = {} } = e;
            try {
              const {
                  gasLimit: e,
                  gasPrice: r,
                  nonce: i,
                } = await this.getNftTransferGasParams(t, a, n),
                s = { to: t, value: K, gas: e, data: a, nonce: i };
              L(oe, this) ? (s.maxFeePerGas = r) : (s.gasPrice = r);
              const o = await this.getCoreLibrary(),
                { rawTransaction: l } = await o.eth.accounts.signTransaction(
                  s,
                  L(ne, this),
                );
              return l;
            } catch (r) {
              throw new d.ExternalError({
                type: u.EXTERNAL_ERROR,
                error: r,
                instance: this,
              });
            }
          }
          async getNonce() {
            try {
              const e = await this.getCoreLibrary();
              return (
                (this.nonce = new this.BN(
                  await e.eth.getTransactionCount(this.address, W),
                )),
                this.nonce
              );
            } catch (e) {
              return void console.error(e);
            }
          }
          async getFeeL1(e) {
            let t,
              { contract: a, amount: n = 1 } = void 0 === e ? {} : e;
            t = a
              ? await this.getTokenFeeL1FromOracle(a, n)
              : await this.getCoinFeeL1FromOracle();
            const r = new this.BN(16)
              .mul(new this.BN(t))
              .mul(new this.BN(684))
              .divn(1e3);
            return r.muln(4);
          }
          async getFeeL2(e) {
            let {
                userGasPrice: t = null,
                gasLimit: a = null,
                contract: n = null,
                amount: r = 1,
              } = void 0 === e ? {} : e,
              i = new this.BN(t || (await this.getGasPrice(!0)));
            L(oe, this) && (i = i.add(i.divn(10)));
            const s =
              a ||
              (n
                ? await this.estimateGas(r, null, n, this.gasLimit)
                : this.gasLimit);
            return i.mul(new this.BN(s));
          }
          async getFee(e) {
            let {
                userGasPrice: t = null,
                gasLimit: a = null,
                contract: n = null,
                amount: r = 1,
              } = void 0 === e ? {} : e,
              i = new this.BN(0);
            if (this.isL2) {
              const e = await this.getFeeL1({ contract: n, amount: r }),
                s = await this.getFeeL2({
                  userGasPrice: t,
                  gasLimit: a,
                  contract: n,
                  amount: r,
                });
              i = e.add(s);
            } else {
              const e = t || (await this.getGasPrice(!0)),
                a = await this.estimateGas(r, null, n);
              i = new this.BN(e).mul(new this.BN(a));
            }
            return i;
          }
          async _getFeeL1FromOracle(e) {
            const t = await this.getCoreLibrary(),
              a = new t.eth.Contract(b.default, B),
              n = await a.methods
                .getL1Fee(e)
                .call()
                .catch(
                  async (e) => (
                    o.default.error({ instance: this, error: e }),
                    new this.BN(this.maxGasLimitL1)
                      .mul(new this.BN(await this._getGasPriceL1FromConfig()))
                      .mul(new this.BN(M))
                  ),
                );
            return new this.BN(String(n));
          }
          async _getGasPriceL1FromConfig() {
            const { fast: e } = await l.default
              .get(h.ConfigKey.EthereumGasPrice)
              .catch(
                (e) => (
                  o.default.error({ instance: this, error: e }),
                  this.maxGasPriceL1
                ),
              );
            return e;
          }
          getCoinFeeL1FromOracle() {
            return this._getFeeL1FromOracle(F);
          }
          getTokenFeeL1FromOracle(e, t) {
            const a = O(le, this, ce).call(this, e, U, t);
            return this._getFeeL1FromOracle(a);
          }
          async getGasPrice(e) {
            let t;
            if ((void 0 === e && (e = !1), L(oe, this))) {
              const e = await this.getCoreLibrary(),
                a = await e.eth.getBlock("pending");
              t = Number(a.baseFeePerGas);
            } else {
              var a, n;
              t = S(le, this, de)
                ? null === (a = await this.getModeratedGasPrice().catch()) ||
                  void 0 === a
                  ? void 0
                  : a.standard
                : Number(
                    null ===
                      (n = await this.getProvider(j).getGasPrice().catch()) ||
                      void 0 === n
                      ? void 0
                      : n.node,
                  );
            }
            const r = t || this.defaultGasPrice * M;
            return e ? r : r + this.gasPriceCoefficient * M;
          }
          async getModeratedGasPrice() {
            try {
              const { fastest: e, safeLow: t } = await l.default.get(
                L(re, this),
              );
              return e && t
                ? { fastest: (e / 10) * M, standard: (t / 10) * M }
                : null;
            } catch (e) {
              return (o.default.error({ instance: this, error: e }), null);
            }
          }
          async estimateGas(e, t, a) {
            const n = t || U,
              r = { from: this.address, to: n, value: e };
            a && (r.data = O(le, this, ce).call(this, a, n, e));
            const i = await this.getCoreLibrary(),
              s = await i.eth
                .estimateGas(r)
                .catch(
                  (e) => (
                    e.message.includes(X) ||
                      o.default.error({ instance: this, error: e }),
                    a ? this.maxGasLimit : this.gasLimit
                  ),
                );
            return Math.round(
              s *
                (a
                  ? this.contractGasLimitCoefficient
                  : this.gasLimitCoefficient),
            );
          }
          async availableBalance(e) {
            if (!this.balance) return null;
            const t = (e && new this.BN(e)) || (await this.getFee()),
              a = new this.BN(this.balance)
                .sub(t)
                .sub(new this.BN(this.unspendableBalance));
            return a.lt(new this.BN(0)) ? "0" : this.toCurrencyUnit(a);
          }
          async getInfo(e) {
            if (
              (await this.initCoreLibrary(),
              await this.getNonce(),
              null !== e && void 0 !== e && e.isToken)
            ) {
              const t = await this.getProvider(
                  j,
                ).getTokenBalanceByContractAddress({
                  address: this.address,
                  contractAddress: e.contract.toLowerCase(),
                }),
                a = [e.contract, e.contract.toLowerCase()];
              a.forEach((e) => {
                this.tokens[e] && (this.tokens[e].balance = t.toString());
              });
            }
            const t = await this.getProvider(q)
              .getInfo(this.address)
              .catch((e) => console.warn(e));
            if (
              (null !== t &&
                void 0 !== t &&
                t.balance &&
                (this.balance = t.balance),
              null === e || void 0 === e || !e.onlyCoin)
            ) {
              const e = Object.values(this.tokens);
              this.getProvider(j).getTokensInfo(e, this.address);
            }
            return {
              balance:
                (null === t || void 0 === t ? void 0 : t.balance) || null,
            };
          }
          getTokenInfo(e) {
            let { contract: t } = e;
            return this.getProvider(j).getTokenBalanceByContractAddress({
              address: this.address,
              contractAddress: t,
            });
          }
          createToken(e) {
            return new s.EVMToken({ parent: this, ...e });
          }
          async getUserTokenList() {
            const e = this.getProvider($),
              t =
                null !== e && void 0 !== e && e.getUserTokenList
                  ? (
                      (await e
                        .getUserTokenList(this.address)
                        .catch((e) => (console.warn(e), []))) || []
                    ).filter((e) => {
                      var t;
                      return null === (t = e.supportedStandards) || void 0 === t
                        ? void 0
                        : t.includes("erc20");
                    })
                  : [];
            return (
              t.forEach((e) => {
                var t;
                let { contract: a, balance: n } = e;
                const r =
                  null !== (t = this.tokens[a]) && void 0 !== t
                    ? t
                    : this.tokens[a.toLowerCase()];
                r && (r.balance = n);
              }),
              t
            );
          }
          async getTokenList() {
            return (
              (this.bannedTokens = await this.getBannedTokenList()),
              l.default
                .get(L(ie, this))
                .catch(
                  (e) => (
                    e instanceof d.UnknownConfigKeyError ||
                      o.default.error({ instance: this, error: e }),
                    []
                  ),
                )
            );
          }
          getBannedTokenList() {
            return l.default
              .get(L(se, this))
              .catch(
                (e) => (
                  e instanceof d.UnknownConfigKeyError ||
                    o.default.error({ instance: this, error: e }),
                  []
                ),
              );
          }
          getTokenObject(e, t) {
            return (
              void 0 === t && (t = "user"),
              "user" === t
                ? this.getTokenFromUserList(e, t)
                : this.getTokenFromCommonList(e, t)
            );
          }
          getTokenFromUserList(e, t) {
            return { ...e, source: t, visibility: !0 };
          }
          async setPrivateKey(e, t) {
            (super.setPrivateKey(e), N(ne, this, e));
            const a = await this.getCoreLibrary(),
              n = await a.eth.accounts.privateKeyToAccount(e);
            this.address = n.address;
          }
          isNftSupported() {
            return !1;
          }
          get feeTicker() {
            return this.id;
          }
          signData(e) {
            return this.coreLibrary.eth.accounts.sign(e, L(ne, this));
          }
          signWithCustomSigner(t) {
            let { data: a, signer: n } = t;
            return n({ ...a, privateKey: e.from(L(ne, this).slice(2), "hex") });
          }
        }
        function ce(e, t, a) {
          return this.getProvider(Q).createSendTokenContract(
            e,
            this.address,
            t,
            a,
          );
        }
        function de(e) {
          return !!L(re, e);
        }
        t.default = EVMCoin;
      }).call(this, a(2).Buffer);
    },
    333: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = t.TICKER_MAPPING = void 0));
      var r = n(a(14)),
        i = n(a(8)),
        s = a(74),
        o = a(19),
        l = n(a(2022)),
        c = n(a(2023)),
        d = n(a(2025));
      function u(e, t) {
        (f(e, t), t.add(e));
      }
      function h(e, t, a) {
        (f(e, t), t.set(e, a));
      }
      function f(e, t) {
        if (t.has(e))
          throw new TypeError(
            "Cannot initialize the same private elements twice on an object",
          );
      }
      function m(e, t, a) {
        return (e.set(y(e, t), a), a);
      }
      function p(e, t) {
        return e.get(y(e, t));
      }
      function y(e, t, a) {
        if ("function" == typeof e ? e === t : e.has(t))
          return arguments.length < 3 ? t : a;
        throw new TypeError("Private element is not present on this object");
      }
      const g = (t.TICKER_MAPPING = {
          "bsc|bnb|": "BSC",
          "trx|usdt|TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t": "TRX-USDT",
          "trx|bttc|TAFjULxiVgT4qWk6UZwjqwZXTSaGaqnVp4": "BTT",
          "nano|xno|": "NANO",
          "op|eth|": "ETHOP",
          "arbitrum|eth|": "ETHARB",
        }),
        w = (e) => {
          let { contract: t, deprecatedParent: a, ticker: n } = e;
          return { contract: t, deprecatedParent: a, ticker: n };
        };
      var T = new WeakMap(),
        v = new WeakSet();
      class ChangeNowService {
        constructor() {
          (u(this, v),
            h(this, T, void 0),
            (this.apiClient = new c.default()),
            (this.walletConverter = new d.default(this.apiClient)));
        }
        getInternalContract(e) {
          let { network: t, ticker: a, tokenContract: n } = e;
          return this.walletConverter.isContractIgnored(t, a) ? void 0 : n;
        }
        getInternalTicker(e) {
          var t;
          let { network: a, ticker: n, tokenContract: r } = e;
          return null !==
            (t = g[`${a}|${n}|${null !== r && void 0 !== r ? r : ""}`]) &&
            void 0 !== t
            ? t
            : n.toUpperCase();
        }
        getInternalWalletData(e) {
          let { network: t, ticker: a, tokenContract: n, legacyTicker: r } = e;
          if (!r)
            return {
              ticker: this.getInternalTicker({
                ticker: a,
                network: t,
                tokenContract: n,
              }),
              parentTicker: t.toUpperCase(),
            };
          const [, i] =
            Object.entries(l.default).find((e) => {
              let [t] = e;
              return t === r.toLowerCase();
            }) || [];
          return i || { ticker: r };
        }
        getName() {
          return "ChangeNow";
        }
        async getDefaultPairQueryParams(e, t) {
          const [a, n] = await Promise.all([
            this.walletConverter.getTarget(e),
            this.walletConverter.getTarget(t),
          ]);
          return {
            fromCurrency: a.ticker,
            fromNetwork: a.network,
            toCurrency: n.ticker,
            toNetwork: n.network,
          };
        }
        async getExchangeAmount(e, t, a) {
          if (!a || !Number(a)) return 0;
          try {
            const n = await this.getDefaultPairQueryParams(e, t),
              { toAmount: r } = await this.apiClient.queryGet(
                "estimated-amount",
                Object.assign({ fromAmount: (a || "0").replace(/,/g, ".") }, n),
              );
            return r;
          } catch (n) {
            throw new o.ExchangeConnectionError();
          }
        }
        async getMinAndMaxAmount(e, t) {
          try {
            const a = await this.getDefaultPairQueryParams(e, t),
              { minAmount: n } = await this.apiClient.queryGet("min-amount", a);
            return { min: n, max: null };
          } catch (a) {
            throw new o.ExchangeConnectionError();
          }
        }
        getCurrencies() {
          return this.apiClient.queryGet("currencies");
        }
        async getConfirmationsData(e, t) {
          try {
            const [a, { confirmations: n }] = await Promise.all([
              y(v, this, C).call(this, e),
              y(v, this, k).call(this, e, t),
            ]);
            return { current: n, required: a, remaining: a > n ? a - n : 0 };
          } catch (a) {
            throw new o.ExchangeConfirmsCalculationError({ cause: a });
          }
        }
        async createTransaction(e, t, a, n, r, i, s, l) {
          void 0 === l && (l = {});
          const [{ network: c, ticker: d }, { network: u, ticker: h }] =
              await Promise.all([
                this.walletConverter.getTarget(e),
                this.walletConverter.getTarget(t),
              ]),
            f = {
              address: a,
              fromAmount: r,
              fromCurrency: d,
              fromNetwork: c,
              toCurrency: h,
              toNetwork: u,
              refundAddress: n,
              flow: "standard",
              type: "direct",
              userId: s.hash,
              payload: { bnb: s.bnbAddr, eth: s.ethAddr },
              ...l,
            };
          i && (f.extraId = i);
          try {
            var m;
            const a = await this.apiClient.queryPost("", f);
            return {
              amountToReceive: a.toAmount,
              amountToSend: a.fromAmount,
              from: Object.assign({ network: e.deprecatedParent }, w(e)),
              to: Object.assign({ network: t.deprecatedParent }, w(t)),
              id: a.id,
              orderId: a.id,
              payinAddress: a.payinAddress,
              payinExtraId:
                null !== (m = a.payinExtraId) && void 0 !== m ? m : null,
              payoutAddress: a.payoutAddress,
            };
          } catch (p) {
            throw new o.ExchangeConnectionError();
          }
        }
        async isAvailableToBuy(e) {
          const { network: t, ticker: a } =
              await this.walletConverter.getTarget(e),
            n = await this.apiClient.queryGet("exchange/currencies", {
              toNetwork: t,
              toCurrency: a,
            });
          return n.length > 0;
        }
        validateExchangeTx(e) {
          const { id: t = "", amountToSend: a = "", payinAddress: n = "" } = e;
          if (!t || "undefined" === typeof t)
            throw new o.ExchangeValidationError();
          if (!a || "undefined" === typeof a)
            throw new o.ExchangeValidationError();
          if (!n || "undefined" === typeof n)
            throw new o.ExchangeValidationError();
          return e;
        }
        async getStatus(e) {
          try {
            const {
              amountReceive: t,
              payinHash: a,
              payoutHash: n,
              status: r,
            } = await this.apiClient.queryGet("by-id", { id: e });
            if ("undefined" !== typeof r)
              return Object.assign(
                { id: e, payinHash: a, payoutHash: n, status: r },
                t ? { amountToReceive: t } : {},
              );
            throw new o.ExchangeConnectionError();
          } catch (t) {
            throw new o.ExchangeConnectionError();
          }
        }
        getTransactions(e) {
          return Promise.all(e.map((e) => this.getStatus(e)));
        }
        getExchangeActions(e) {
          return this.apiClient.queryGet("actions", { id: e });
        }
        exchangeContinue(e) {
          return this.apiClient.queryPost("continue", { id: e });
        }
        exchangeRefund(e, t, a) {
          return this.apiClient.queryPost(
            "refund",
            Object.assign({ address: t, id: e }, a ? { extraId: a } : {}),
          );
        }
      }
      async function b() {
        return (
          void 0 === p(T, this) &&
            m(
              T,
              this,
              r.default.get(
                "https://move-api.atomicwallet.io/affiliate/confirmations",
              ),
            ),
          (await p(T, this)).data
        );
      }
      async function C(e) {
        const [t, a] = await Promise.all([
            y(v, this, b).call(this),
            i.default.get(s.ConfigKey.ChangeNowUniqueTickers),
          ]),
          { confirmations: n } = t.find((t) => {
            var n;
            let { ticker: r, network: i } = t;
            return e.isMatch({
              ticker: null !== (n = a[r]) && void 0 !== n ? n : r,
              parent: i,
            });
          });
        return n;
      }
      async function k(e, t) {
        return e.getTransaction(t);
      }
      t.default = ChangeNowService;
    },
    340: function (e, t, a) {
      "use strict";
      function n({ ticker: e, chainId: t, walletType: a = "EVM" }) {
        return `${e.toUpperCase()}${t}`;
      }
      (a.r(t),
        a.d(t, "generateId", function () {
          return n;
        }));
    },
    35: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.WALLETS = t.CONFIGS = void 0));
      ((t.WALLETS = {
        NEW_ATOMIC_ID: "new_atomic_id",
        FINISH_LOADING: "finish-loading",
        FINISH_LOADING_ALL: "finish-loading-all",
        WALLETS_READY_TO_DISPLAY: "wallets-ready-to-display",
        RAISE_LOADING_ERROR: "raise-loading-error",
        START_LOADING: "start-loading",
        START_LOADING_ALL: "start-loading-all",
        UPDATE_LOADING_PROGRESS: "update-loading-progress",
        TX_SENT: "tx-sent",
        WALLET_READY: "wallet-ready",
        NEW_COINS_LOADED: "new-coins-loaded",
        DEACTIVATE_COIN: "deactivate_coin",
        UPDATE: "wallets-update",
        BALANCE_UPDATED: "balance-updated",
      }),
        (t.CONFIGS = {
          UPDATE: "update_config",
          UPDATED: "config_updated",
          LOG_SETTINGS_UPDATED: "log_settings_config_updated",
          FAILED_FETCH: "failed_fetch",
        }));
    },
    382: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0),
        (t.loadTokensFromDb = y));
      var r = n(a(28)),
        i = a(19),
        s = n(a(432)),
        o = a(4),
        l = a(27),
        c = n(a(21)),
        d = n(a(8));
      const u = 9,
        h = 30,
        f = "user",
        m = "list";
      let p = null;
      function y() {
        return (p || (p = o.db.tokens.toArray()), p);
      }
      const g = (e) =>
        class extends e {
          constructor(e) {
            (super(e), (this.tokens = {}));
          }
          async _insertBatchTokens(e) {
            return (await o.db.tokens.bulkPut(e), (p = null), e);
          }
          async _updateBatchTokens(e) {
            const t = [];
            for (const a of e) t.push(this._updateToken(a));
            return (await Promise.all(t), e);
          }
          async _updateToken(e) {
            const t = await o.db.tokens
              .where({ uniqueField: e.uniqueField })
              .first()
              .catch((e) => r.default.error({ instance: this, error: e }));
            if (t && t.id)
              return (await o.db.tokens.update(t.id, e), (p = null), e);
          }
          async _removeToken(e) {
            const t = await o.db.tokens
              .where({ uniqueField: e })
              .first()
              .catch((e) => r.default.error({ instance: this, error: e }));
            (t && t.id && (await o.db.tokens.delete(t.id)), (p = null));
          }
          async loadTokensFromDb(e, t) {
            void 0 === t && (t = (t) => t.parentTicker === e);
            const a = await y();
            return e ? a.filter(t) : a;
          }
          async insertTokensToDb(e) {
            const t = e
                .map((e) => ((e.parentTicker = this.id), e))
                .filter((e) => e),
              [a] = await this.getUniquesAndDuplicates(e),
              n = t.filter((e) => void 0 === a[e.uniqueField]);
            return (await this._insertBatchTokens(n), n);
          }
          async updateTokensInDb(e, t) {
            const a = await this.loadTokensFromDb(this.id, (e) =>
                [this.id, this.ticker].includes(e.parentTicker),
              ),
              n = a.map((e) => {
                let { uniqueField: t } = e;
                return t.toLowerCase();
              }),
              r = e.reduce((e, t) => {
                let {
                  uniqueField: a,
                  ticker: r,
                  name: i,
                  source: s,
                  isCustom: o,
                  ...l
                } = t;
                return (
                  n.includes(a.toLowerCase()) &&
                    ("list" !== s || o
                      ? e.push({
                          ...l,
                          uniqueField: a,
                          source: s,
                          parentTicker: this.id,
                        })
                      : e.push({
                          ...l,
                          uniqueField: a,
                          ticker: r,
                          name: i,
                          source: s,
                          isCustom: o,
                          parentTicker: this.id,
                        })),
                  e
                );
              }, []);
            return (await this._updateBatchTokens(r), r);
          }
          async removeTokenFromDb(e) {
            await this._removeToken(e);
          }
          async loadTokensList(e) {
            if (!this.isTokensSupported) return [];
            try {
              this.bannedTokens = (await this.getBannedTokenList()) || [];
              const t = m,
                a = (await this.getTokenList()) || [],
                n = this.processTokenList(
                  await this.setTokensConfirmation(a, e, t),
                  t,
                ),
                r = n.filter((e) => e.uniqueField).map((e) => e.uniqueField);
              (await this.deleteDuplicates(n),
                await this.updateTokensInDb(n, t),
                await this.bulkDeleteWhereNotInList(
                  (e) =>
                    e.source === t && !e.isCustom && !r.includes(e.uniqueField),
                ));
              const i =
                  r.length > 0
                    ? await o.db.tokens.where("uniqueField").anyOf(r).toArray()
                    : [],
                s = i.map((e) => e.uniqueField),
                l = n.filter((e) => !s.includes(e.uniqueField));
              return (
                await this.insertTokensToDb(l),
                this.createTokens([...i, ...l], e)
              );
            } catch (t) {
              throw (
                console.warn(
                  "[HasTokensMixin] loadTokensList failed with error " + t,
                ),
                new s.default({
                  type: l.INTERNAL_ERROR,
                  error: t,
                  instance: this,
                })
              );
            }
          }
          async fetchUserTokens(e) {
            const t = await this.loadTokensFromDb(this.id);
            t && 0 === t.length
              ? await this.loadTokensList(e)
              : this.createTokens(await this.setTokensConfirmation(t, e, f), e);
            const a = this.getUserTokenList
                ? await this.getUserTokenList()
                : [],
              n = await this.processTokenList(
                await this.setTokensConfirmation(a, e, f),
                f,
              ),
              r = await this.insertTokensToDb(n);
            return this.createTokens(r, e);
          }
          async setTokensConfirmation(e, t, a) {
            if ((void 0 === e && (e = []), "undefined" === typeof t))
              throw new TypeError(
                "#setTokensConfirmation Error: wallets instance is not defined",
              );
            if (!this.isTokensSupported) return [];
            const n = await this.getTokenList(),
              r = n.map((e) => e.ticker).filter(Boolean),
              i = d.default.getWhitelistedFallbackTokens(),
              s = i
                .map((e) => {
                  var t;
                  return null === (t = e.name) || void 0 === t
                    ? void 0
                    : t.toUpperCase();
                })
                .filter(Boolean),
              o = i
                .map((e) => {
                  var t;
                  return null !== (t = e.ticker) && void 0 !== t ? t : e.symbol;
                })
                .filter(Boolean),
              l = t
                .list()
                .filter((e) => !(e instanceof c.default))
                .map((e) => e.ticker);
            return e.reduce((e, t) => {
              var i, c;
              if (a === m) return ((t.confirmed = !0), e);
              const [d] = n.filter((e) => {
                var a, n, r;
                let { contract: i, owner: s, mint: o } = e;
                return (
                  ((null === i || void 0 === i ? void 0 : i.toLowerCase()) ||
                    (null === s || void 0 === s ? void 0 : s.toLowerCase()) ||
                    (null === o || void 0 === o ? void 0 : o.toLowerCase())) ===
                  ((null === (a = t.contract) || void 0 === a
                    ? void 0
                    : a.toLowerCase()) ||
                    (null === (n = t.owner) || void 0 === n
                      ? void 0
                      : n.toLowerCase()) ||
                    (null === (r = t.mint) || void 0 === r
                      ? void 0
                      : r.toLowerCase()))
                );
              });
              if (d)
                return ((t.confirmed = !0), (t.isStakable = d.isStakable), e);
              const u = null !== (i = t.ticker) && void 0 !== i ? i : t.symbol,
                h = null === u || void 0 === u ? void 0 : u.toUpperCase(),
                f =
                  null === (c = t.name) || void 0 === c
                    ? void 0
                    : c.toUpperCase(),
                p = !l.includes(h),
                y = !l.includes(t.name),
                g = !o.includes(h),
                w = !s.includes(f),
                T = !r.includes(h),
                v = /^[a-zA-Z0-9\-_.]+$/.test(h),
                b = /^[a-zA-Z0-9\-_.]+$/.test(t.name),
                C = v && b;
              return ((t.confirmed = p && g && w && T && y && C), e);
            }, e);
          }
          processTokenList(e, t) {
            return (
              void 0 === e && (e = []),
              Array.isArray(e)
                ? e
                    .map((e) => this.getTokenObject(e, t))
                    .filter((e) => this.isTokenExcluded(e))
                    .filter(
                      (e) =>
                        !!e.ticker &&
                        !!e.name &&
                        /^[a-zA-Z0-9 -_.]+$/.test(e.ticker),
                    )
                    .filter(
                      (e) =>
                        "" !== e.ticker.trim() &&
                        !(e.ticker.length > u || e.name.length > h),
                    )
                    .map((e) => ({ ...e, source: t }))
                : []
            );
          }
          async getTokenList() {
            throw new i.UndeclaredAbstractMethodError("getTokenList", this);
          }
          async getBannedTokenList() {
            return [];
          }
          getExcludedTokenList() {
            const e = Array.isArray(this.bannedTokens) ? this.bannedTokens : [];
            return e.map((e) => e.toLowerCase());
          }
          async getUserTokenList() {
            return [];
          }
          isTokenExcluded(e) {
            return !this.getExcludedTokenList().includes(
              e.contract.toLowerCase(),
            );
          }
          getTokenObject(e, t) {
            return (
              void 0 === t && (t = "user"),
              "user" === t
                ? this.getTokenFromUserList(e, t)
                : this.getTokenFromCommonList(e, t)
            );
          }
          getTokenFromUserList(e, t) {
            var a, n;
            return {
              name: e.name,
              ticker: e.symbol,
              decimal: Number(e.decimals) || 0,
              contract:
                null === (a = e.contractAddress) || void 0 === a
                  ? void 0
                  : a.toLowerCase(),
              parentTicker: this.id,
              uniqueField:
                null === (n = e.contractAddress) || void 0 === n
                  ? void 0
                  : n.toLowerCase(),
              visibility: !0,
              confirmed: e.confirmed,
              config: e.config,
              source: t,
              notify: e.notify,
              imgUri: e.imgUri,
            };
          }
          getTokenFromCommonList(e, t) {
            return {
              name: e.name,
              ticker: e.ticker,
              decimal: Number(e.decimal) || 0,
              contract: e.contract.toLowerCase(),
              parentTicker: this.id,
              uniqueField: e.contract.toLowerCase(),
              visibility: !1 !== e.visibility,
              confirmed: e.confirmed,
              config: e.config,
              source: e.source || t,
              notify: Boolean(e.notify),
            };
          }
          async updateCustomToken(e, t) {
            await this.removeTokenFromDb(e.uniqueField);
            for (const r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            const a = {
                name: e.name,
                ticker: e.ticker,
                decimal: Number(e.decimal),
                contract: e.contract.toLowerCase(),
                parentTicker: e.parent,
                uniqueField: e.contract.toLowerCase(),
                notify: Boolean(e.notify),
              },
              n = await this.insertTokensToDb([a]);
            return n;
          }
          async validateCustomToken(e) {
            let { name: t, ticker: a, decimal: n, contract: r } = e;
            const i = this.tokens[r.toLowerCase()];
            if (i) throw new Error(this.ticker + ": Contract already exists");
          }
          async createCustomToken(e, t) {
            let {
              name: a,
              ticker: n,
              decimal: r,
              contract: i,
              uniqueField: s,
              source: o = "custom",
            } = e;
            const l = { name: a, ticker: n, decimal: r, contract: i };
            await this.validateCustomToken(l);
            const c = await this.setTokensConfirmation(
                [
                  {
                    uniqueField: s,
                    visibility: !0,
                    source: o,
                    isCustom: !0,
                    ...l,
                  },
                ],
                t,
              ),
              d = this.createTokens(c, t);
            return (
              await this.insertTokensToDb(
                d.map((e) => this.getTokenObject(e, o)),
              ),
              d
            );
          }
          createTokens(e, t) {
            void 0 === e && (e = []);
            const a = e,
              n = [];
            if (0 !== e.length)
              return (
                a.forEach((e) => {
                  const a = t.getWallet(
                    (0, o.getTokenId)({
                      contract: e.contract,
                      parent: this.id,
                      ticker: e.ticker,
                    }),
                  );
                  if (a && a.uniqueField === e.uniqueField)
                    return (
                      (a.visibility = e.visibility),
                      void (e.source === m && (a.notify = Boolean(e.notify)))
                    );
                  const r = this.createToken({
                    name: e.name,
                    ticker: e.ticker,
                    decimal: e.decimal,
                    contract: e.contract.toLowerCase(),
                    uniqueField: e.uniqueField,
                    visibility: !1 !== e.visibility,
                    confirmed: e.confirmed,
                    denom: e.denom,
                    source: e.source,
                    isStakable: e.isStakable,
                    config: {
                      ...(e.config || {}),
                      memoRegexp: this.config.hasTokenMemo
                        ? e.memoRegexp || this.config.memoRegexp
                        : null,
                      paymentIdLabelType: this.config.hasTokenMemo
                        ? this.config.paymentIdLabelType
                        : null,
                    },
                    notify: Boolean(e.notify),
                    mint: e.mint,
                    tokenTypePostfix: e.tokenTypePostfix,
                    imgUri: e.imgUri,
                  });
                  (n.push(r),
                    t.addWallet(r),
                    (this.tokens[e.contract.toLowerCase()] = r));
                }),
                this.eventEmitter.emit("update::coin-list"),
                n
              );
          }
          async getUniquesAndDuplicates(e) {
            const t = await o.db.tokens
                .where(["parentTicker", "uniqueField"])
                .anyOf(
                  e
                    .filter(
                      (e) =>
                        (null === e || void 0 === e ? void 0 : e.uniqueField) &&
                        (null === e || void 0 === e ? void 0 : e.parentTicker),
                    )
                    .map((e) => [e.parentTicker, e.uniqueField]),
                ),
              a = {},
              n = [];
            return (
              await t.each((e) => {
                a[e.uniqueField] ? n.push(e.id) : (a[e.uniqueField] = e.id);
              }),
              [a, n]
            );
          }
          async deleteDuplicates(e) {
            try {
              const [, t] = await this.getUniquesAndDuplicates(e),
                a = o.db.tokens.where("id").anyOf(t).delete();
              return ((p = null), a);
            } catch (t) {
              return void console.error(t);
            }
          }
          async bulkDeleteWhereNotInList(e) {
            const t = await o.db.tokens
              .where("parentTicker")
              .equals(this.id)
              .filter(e)
              .toArray();
            (await o.db.tokens
              .where("id")
              .anyOf(t.map((e) => e.id))
              .delete(),
              (p = null));
          }
        };
      t.default = g;
    },
    384: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "SOL_TOKEN_REQUEST_TYPE", {
          enumerable: !0,
          get: function () {
            return i.SOL_TOKEN_REQUEST_TYPE;
          },
        }),
        Object.defineProperty(t, "TxTypes", {
          enumerable: !0,
          get: function () {
            return r.default;
          },
        }));
      var r = n(a(852)),
        i = a(1987);
    },
    386: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = a(872),
        i = n(a(1770)),
        s = n(a(293));
      const o = "250000",
        l =
          "115792089237316195423570985008687907853269984665640564039457584007913129639935",
        c = (e) =>
          class extends e {
            createSmartContractCall(e) {
              var t;
              let {
                type: a = "ERC20",
                smartContractAddress: n,
                standard: r = !1,
                action: s,
                args: o = [],
              } = void 0 === e ? {} : e;
              if (!a)
                throw new Error(
                  "One of supported 'type' should be defined: [" +
                    Object.keys(i.default).toString(),
                );
              if (!n)
                throw new Error(
                  "argument `smartContractAddress` should be defined!",
                );
              const l =
                null === (t = i.default[a.toUpperCase()]) || void 0 === t
                  ? void 0
                  : t[r ? "standard" : n.toLowerCase()];
              if (!l)
                throw new Error(
                  `Smart-contract ${a.toUpperCase()} ${n} is not supported`,
                );
              const { name: c, params: d } = l.methods[s] || {};
              if (!c)
                throw new Error(
                  `Smart-contract action '${s}' is not supported, supported actions: [${Object.keys(l.methods).toString()}]`,
                );
              if ((null === d || void 0 === d ? void 0 : d.length) > o.length)
                throw new Error(
                  `Smart-contract parameters should include ${d.length} values, got ${o.length}`,
                );
              const u = l.abi;
              if (!u) throw new Error(`No such ${a} ABI found for ${n}`);
              const h = new this.coreLibrary.eth.Contract(u, n, o);
              if ("function" !== typeof h.methods[c])
                throw new TypeError(
                  `${this.constructor.name}: "${c}" is not implemented in provided smart-contract ABI methods`,
                );
              return h.methods[c](...o).encodeABI();
            }
            makeRawCall(e, t, a, n) {
              void 0 === n && (n = []);
              const r = new this.coreLibrary.eth.Contract(e, t);
              return r.methods[a](...n).call();
            }
            async getContractConstants(e) {
              const t = new this.coreLibrary.eth.Contract(s.default, e),
                a = new this.coreLibrary.BatchRequest(),
                n = s.default.filter((e) => {
                  let { constant: t, type: a, inputs: n } = e;
                  return t && "function" === a && 0 === n.length;
                }),
                r = {},
                i = [];
              for (let s = 0; s < n.length; s += 1) {
                const e = n[s].name,
                  o = new Promise((n, i) => {
                    const s = (t, a) => {
                      (t &&
                        (console.warn(
                          `Web3Mixin: Failed to call method '${e}'`,
                          t,
                        ),
                        i(t)),
                        (r[e] = a),
                        n(a));
                    };
                    a.add(t.methods[e]().call.request(s));
                  });
                i.push(o);
              }
              return (await a.execute(), await Promise.allSettled(i), r);
            }
            async decodeTransactionData(e) {
              const t = new r.ethers.utils.Interface(s.default),
                a = t.parseTransaction({ data: e });
              return a;
            }
            async estimateDataGas(e) {
              var t;
              let { contract: a, data: n, amount: r = "0x0" } = e;
              const i = await this.coreLibrary.eth
                .estimateGas({
                  from: this.address,
                  to: a,
                  nonce: Number(this.nonce.add(new this.BN(1))),
                  value: r,
                  data: n,
                })
                .catch((e) => {
                  console.error(
                    this.ticker +
                      ": Failed to estimate gas, used default max 250k",
                    e,
                  );
                });
              return i
                ? Math.ceil(
                    i *
                      (null !== (t = this.gasLimitCoefficient) && void 0 !== t
                        ? t
                        : 1),
                  ).toString()
                : o;
            }
            getAllowance(e) {
              let { contract: t, spender: a, abi: n = s.default } = e;
              const r = new this.coreLibrary.eth.Contract(n, t);
              return r.methods.allowance([this.address, a]).call();
            }
            makeApproval(e) {
              let { contract: t, address: a, amount: n } = e;
              const r = this.createSmartContractCall({
                smartContractAddress: t,
                standard: !0,
                action: "approve",
                args: [a, n],
              });
              return r;
            }
            createApproveTransaction(e) {
              let {
                contract: t,
                address: a,
                amount: n,
                userGasPrice: r,
                gasLimit: i,
                multiplier: s,
                nonce: o,
              } = void 0 === e ? {} : e;
              const c = this.makeApproval({
                contract: t,
                address: a,
                amount: null !== n && void 0 !== n ? n : l,
              });
              return this.createTransaction({
                address: t,
                amount: "0",
                paymentData: c,
                nonce: null !== o && void 0 !== o ? o : this.nonce,
                userGasPrice: r,
                gasLimit: i,
                multiplier: s,
              });
            }
          };
      t.default = c;
    },
    399: function (e, t, a) {
      "use strict";
      (a.r(t),
        a.d(t, "CurrencyType", function () {
          return n;
        }),
        a.d(t, "IntervalType", function () {
          return r;
        }),
        a.d(t, "OperationState", function () {
          return i;
        }),
        a.d(t, "ProviderName", function () {
          return s;
        }));
      var n = ((e) => ((e["Fiat"] = "fiat"), (e["Asset"] = "asset"), e))(
          n || {},
        ),
        r = ((e) => ((e["Monthly"] = "monthly"), e))(r || {}),
        i = ((e) => (
          (e["Pending"] = "pending"),
          (e["Active"] = "active"),
          (e["Cancelled"] = "cancelled"),
          e
        ))(i || {}),
        s = ((e) => (
          (e["Guardarian"] = "guardarian"),
          (e["ChangeNow"] = "changenow"),
          (e["Simplex"] = "simplex"),
          (e["MoonPay"] = "moonpay"),
          e
        ))(s || {});
    },
    403: function (e, t, a) {
      "use strict";
      (a.r(t),
        a.d(t, "generateExplorerConfig", function () {
          return s;
        }),
        a.d(t, "generateDefaultFeeConfig", function () {
          return o;
        }),
        a.d(t, "isRpcBaseUrlValid", function () {
          return l;
        }),
        a.d(t, "createEVMCoin", function () {
          return c;
        }));
      var n = a(241),
        r = a.n(n),
        i = a(340);
      const s = ({ chainId: e, rpcBaseUrl: t }) => ({
          className: "Web3Explorer",
          baseUrl: new URL(t).origin,
          chainId: e,
          usedFor: ["node", "balance", "tx", "send"],
        }),
        o = () => ({
          defaultGasPrice: 150,
          defaultMaxGasPrice: 1e3,
          gasPriceCoefficient: 1,
          nftGasPriceCoefficient: 1,
          gasLimit: 21e3,
          maxGasLimit: 15e4,
          gasLimitCoefficient: 1,
          nftGasLimitCoefficient: 1,
          resendTimeout: 3,
          unspendableBalance: 0,
        });
      function l(e) {
        try {
          const t = new URL(e);
          return "https:" === t.protocol;
        } catch (t) {
          throw new TypeError("CreateEVMCoin: Invalid RPC Url");
        }
      }
      function c({
        ticker: e,
        name: t,
        chainId: a,
        rpcBaseUrl: n,
        explorerWebUrl: c = "https://etherscan.io",
        features: d,
      }) {
        if (!e || !t || !a || !n)
          throw new TypeError(
            "CreateEVMCoin: Missing arguments.\n Every of [ticker, name, chainId, rpcBaseUrl] must be provided!",
          );
        if (!l(n))
          throw new TypeError(
            "CreateEVMCoin: [rpcBaseUrl] should be `https` only`",
          );
        const u = s({ chainId: a, rpcBaseUrl: n });
        return new r.a({
          id: Object(i["generateId"])({
            ticker: e,
            chainId: a,
            walletType: "EVM",
          }),
          alias: "atomic",
          name: t,
          ticker: e,
          chainId: a,
          features: d,
          feeData: o(),
          explorers: [u],
          isL2: !1,
          isUseModeratedGasPrice: !1,
          isUseEIP1559: !1,
          txWebUrl: c.replace(/\/+$/, "") + "/tx/",
          socket: !1,
          isCustom: !0,
        });
      }
    },
    432: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(69)),
        i = a(27),
        s = n(a(132));
      class InternalError extends s.default {
        constructor(e) {
          (super(e),
            (0, r.default)(this, "defaultType", i.INTERNAL_ERROR),
            (this.name = this.constructor.name));
        }
      }
      t.default = InternalError;
    },
    434: function (e) {
      e.exports = JSON.parse(
        '{"default":{"CONFIGS_BASE_URL":"https://services.atomicwallet.io","REFERRAL_PROGRAM_API_URL":"https://invite-friends.atomicwallet.io"},"stage":{"CONFIGS_BASE_URL":"https://services-stage.atomicwallet.io","REFERRAL_PROGRAM_API_URL":"http://invite-friends.anyswap.co"},"dev":{"CONFIGS_BASE_URL":"https://services-dev.atomicwallet.io","REFERRAL_PROGRAM_API_URL":"http://invite-friends.anyswap.co"},"localhost":{"CONFIGS_BASE_URL":"http://localhost:9090","REFERRAL_PROGRAM_API_URL":"http://localhost:9090"}}',
      );
    },
    680: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(336)),
        i = n(a(402)),
        s = n(a(2026)),
        o = n(a(256)),
        l = n(a(257)),
        c = a(681),
        d = a(4),
        u = n(a(37)),
        h = n(a(2028));
      function f(e, t) {
        (m(e, t), t.add(e));
      }
      function m(e, t) {
        if (t.has(e))
          throw new TypeError(
            "Cannot initialize the same private elements twice on an object",
          );
      }
      function p(e, t, a) {
        if ("function" == typeof e ? e === t : e.has(t))
          return arguments.length < 3 ? t : a;
        throw new TypeError("Private element is not present on this object");
      }
      const y = "https://ob.atomicwallet.io/",
        g =
          /^([a-f0-9]{8})([a-f0-9]{4})([a-f0-9]{4})([a-f0-9]{4})([a-f0-9]{12})$/,
        w = /{.*}/;
      var T = new WeakSet();
      class Simplex extends s.default {
        constructor(e) {
          (void 0 === e && (e = y), super(e), f(this, T));
        }
        createExchangeClient(e) {
          return new h.default(e);
        }
        getAvailableWallets() {
          return o.default.settings.availableWallets
            .filter((e) => {
              let { ticker: t } = e;
              return l.default.isAllowed(t.toUpperCase(), c.ACTION_BUY);
            })
            .map((e) => {
              let { id: t } = e;
              return t;
            });
        }
        getAvailableFiats() {
          return o.default.settings.fiats;
        }
        async getExchangeRate(e, t, a, n, r) {
          if (!e || !t || !a || !n || !r)
            throw new TypeError(
              "Initial values should be defined: `fiatToSend`, `coinToReceive`, `amount`, `walletHash`, `requestToken",
            );
          const i = this.hashFormat(n),
            { ip: s } = await (0, d.getGeo)(),
            l = {
              digital_currency: o.default.getSimplexTicker(t),
              fiat_currency: e,
              requested_currency: e,
              requested_amount: Number(a),
              end_user_id: i,
              wallet_id: "atomicwallet",
              client_ip: s,
            };
          try {
            const { response: e, token: t } = await this.client.getQuote(l, r);
            if (e.data.result.error) throw e.data.result;
            const a = e.data.result.quote_id,
              s = this.getPaymentId(a, n),
              o = this.getOrderId(s),
              c = this.getCookieUaid(o),
              d = this.getCookieSession(c),
              u = e.data.result.fiat_money.total_amount,
              h = e.data.result.digital_money.amount.toString();
            return {
              totalFiatAmount: u,
              requestedCoinAmount: h,
              userId: i,
              quoteId: a,
              paymentId: s,
              orderId: o,
              cookieUaid: c,
              cookieSession: d,
              token: t,
            };
          } catch (u) {
            var c;
            if (
              "string" ===
              typeof (null === (c = u.response) || void 0 === c
                ? void 0
                : c.data)
            ) {
              const e = JSON.parse(u.response.data.match(w)[0]);
              throw e.detailed_errors.errors[0];
            }
            throw u.detailed_errors.errors[0];
          }
        }
        hashFormat(e) {
          return e.replace(g, "$1-$2-$3-$4-$5");
        }
        getPaymentId(e, t) {
          if (!e || !t)
            throw new TypeError("`quoteId` and `wallethash` should be defined");
          const a = Math.random().toString(36);
          return this.hashFormat(r.default.hash(e + t + a));
        }
        getOrderId(e) {
          if (!e) throw new TypeError("`paymentId` should be defined");
          return this.hashFormat(r.default.hash(e));
        }
        getCookieUaid(e) {
          if (!e) throw new TypeError("`orderId` should be defined");
          return this.hashFormat((0, i.default)(e));
        }
        getCookieSession(e) {
          if (!e) throw new TypeError("`cookieUaid` should be defined");
          return this.hashFormat((0, i.default)(e));
        }
        createExchangeTransaction(e) {
          let {
            userId: t,
            quoteId: a,
            paymentId: n,
            orderId: r,
            cookieUaid: i,
            cookieSession: s,
            fiatTicker: o,
            fiatAmount: l,
            coinAmount: c,
            coinAddress: d,
            coin: u,
            geo: h,
            ip: f,
          } = e;
          const m = {
            userId: t,
            quoteId: a,
            paymentId: n,
            orderId: r,
            cookieUaid: i,
            cookieSession: s,
            fiatTicker: o,
            fiatAmount: l,
            coinAmount: c,
            coinAddress: d,
            coin: u,
            geo: h,
            ip: f,
          };
          return {
            paymentRequestPayload: p(T, this, v).call(this, m),
            submitRequestPayload: p(T, this, b).call(this, m),
          };
        }
        async makeExchange(e) {
          let { paymentRequestPayload: t, submitRequestPayload: a } = e;
          await this.client.requestPayment(t);
          const { data: n } = await this.client.submitPayment(a);
          return n.result;
        }
      }
      function v(e) {
        let {
          userId: t,
          quoteId: a,
          paymentId: n,
          orderId: r,
          cookieUaid: i,
          cookieSession: s,
          fiatTicker: l,
          fiatAmount: c,
          coinAmount: d,
          coinAddress: h,
          coin: f,
          geo: m,
          ip: p,
        } = e;
        return {
          account_details: {
            app_provider_id: "atomicwallet",
            app_version_id: u.default.getVersion(),
            app_end_user_id: t,
            app_install_date: new Date(),
            signup_login: {
              ip: p,
              location: m,
              uaid: i,
              accept_language: "en-US;q=0.7,en;",
              http_accept_language: "en-US;q=0.7,en;",
              user_agent: navigator.userAgent,
              cookie_session_id: s,
              timestamp: new Date(),
            },
          },
          transaction_details: {
            payment_details: {
              quote_id: a,
              payment_id: n,
              order_id: r,
              fiat_total_amount: { currency: l, amount: Number(c) },
              requested_digital_amount: {
                currency: o.default.getSimplexTicker(f),
                amount: Number(d),
              },
              destination_wallet: {
                currency: o.default.getSimplexTicker(f),
                address: h,
              },
              original_http_ref_url: "https://atomicwallet.io",
            },
          },
        };
      }
      function b(e) {
        let {
          userId: t,
          quoteId: a,
          paymentId: n,
          fiatTicker: r,
          fiatAmount: i,
          coinAmount: s,
          coinAddress: l,
          coin: c,
        } = e;
        return {
          version: "1",
          partner: "atomicwallet",
          payment_flow_type: "wallet",
          return_url: "https://atomicwallet.io",
          quote_id: a,
          payment_id: n,
          user_id: t,
          destination_wallet: {
            address: l,
            currency: o.default.getSimplexTicker(c),
          },
          fiat_total_amount: { amount: i, currency: r },
          digital_total_amount: {
            amount: s,
            currency: o.default.getSimplexTicker(c),
          },
        };
      }
      t.default = Simplex;
    },
    682: function (e, t) {},
    683: function (e, t) {},
    790: function (e, t, a) {
      "use strict";
      (a.r(t),
        a.d(t, "banner", function () {
          return c;
        }));
      var n = a(8),
        r = a.n(n),
        i = a(19),
        s = a(4),
        o = (e, t, a) =>
          new Promise((n, r) => {
            var i = (e) => {
                try {
                  o(a.next(e));
                } catch (t) {
                  r(t);
                }
              },
              s = (e) => {
                try {
                  o(a.throw(e));
                } catch (t) {
                  r(t);
                }
              },
              o = (e) =>
                e.done ? n(e.value) : Promise.resolve(e.value).then(i, s);
            o((a = a.apply(e, t)).next());
          });
      const l = "key";
      class Banner_Banner {
        shouldBeShown() {
          return o(this, null, function* () {
            var e, t;
            const { viewCount: a } =
              null != (e = yield this.getContent()) ? e : {};
            if (!a) return !1;
            const { views: n } =
              null != (t = yield this.getBannerRecordFromDb())
                ? t
                : { views: 0 };
            return n < a;
          });
        }
        getContent() {
          return o(this, null, function* () {
            try {
              if (this.cache) return this.cache;
              const [e, { banner: t } = { banner: void 0 }] = yield Promise.all(
                  [
                    r.a.get(n["ConfigKey"].Banner, !0),
                    this.getBannerRecordFromDb(),
                  ],
                ),
                a = JSON.stringify(e);
              return (
                a !== t && (yield this.saveToDbAndResetViews(a)),
                (this.cache = e),
                this.cache
              );
            } catch (e) {
              throw new i["ExternalError"]({ error: e, instance: this });
            }
          });
        }
        incrementViews() {
          return o(this, null, function* () {
            var e;
            try {
              const { banner: t, views: a } =
                null != (e = yield s["db"].banner.get(l)) ? e : {};
              if (void 0 === t || void 0 === a)
                throw new Error("No banner in db");
              yield s["db"].banner.put({ key: l, banner: t, views: a + 1 });
            } catch (t) {
              throw new i["ExternalError"]({ error: t, instance: this });
            }
          });
        }
        getBannerRecordFromDb() {
          return s["db"].banner.get(l);
        }
        saveToDbAndResetViews(e) {
          return o(this, null, function* () {
            yield s["db"].banner.put({ key: l, banner: e, views: 0 });
          });
        }
      }
      const c = new Banner_Banner();
    },
    793: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "DomainsPlugin", {
          enumerable: !0,
          get: function () {
            return r.default;
          },
        }));
      var r = n(a(1242));
    },
    815: function (e, t, a) {
      "use strict";
      (function (e) {
        var n = a(0);
        (Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0));
        var r = n(a(8)),
          i = n(a(129)),
          s = n(a(80)),
          o = a(19),
          l = a(27);
        const c = [
            {
              constant: !0,
              inputs: [{ name: "_owner", type: "address" }],
              name: "balanceOf",
              outputs: [{ name: "balance", type: "uint256" }],
              type: "function",
            },
          ],
          d = 1e4;
        class Web3Explorer extends i.default {
          constructor() {
            (super(...arguments), (this.requestId = 0));
          }
          getAllowedTickers() {
            return [
              "ETH",
              "ETC",
              "BSC",
              "MATIC",
              "AVAX",
              "FLR",
              "FTM",
              "FIL",
              "ETHOP",
            ];
          }
          async getInfo(e, t) {
            void 0 === t && (t = !1);
            const a = e
              ? await this.wallet.coreLibrary.eth.getBalance(e).catch((e) => {
                  throw new o.ExplorerRequestError({
                    type: l.GET_BALANCE_TYPE,
                    error: e,
                    instance: this,
                  });
                })
              : null;
            return { balance: a, transactions: [] };
          }
          async getTokensInfo(e, t) {
            const a = e.length,
              n = new this.wallet.coreLibrary.BatchRequest();
            for (let r = 0; r < a; r += 1) {
              const a = e[r],
                i = a.contract,
                s = (e, t) => {
                  (e &&
                    console.warn(
                      `Web3Explorer: Failed to fetch ${a.ticker} token balance`,
                      e,
                    ),
                    (a.balance = t));
                };
              n.add(
                this.getTokenBalanceOfCall(
                  { address: t, contractAddress: i.toLowerCase() },
                  s,
                ),
              );
            }
            return (await n.execute(), a);
          }
          async getTransaction(e, t, a) {
            let n = this.wallet;
            const r = await this.wallet.coreLibrary.eth.getTransaction(t);
            if (!r) return null;
            const { timestamp: i } = await this.wallet.coreLibrary.eth.getBlock(
                r.blockNumber,
              ),
              { number: o } =
                await this.wallet.coreLibrary.eth.getBlock("latest"),
              l = await this.wallet.coreLibrary.eth.getTransactionReceipt(t);
            return (
              "0x" !== r.input &&
                ((r.inputDecode = this.decodeInput(r.input)),
                l &&
                  r.inputDecode &&
                  "transfer" === r.inputDecode.method &&
                  l.to &&
                  a &&
                  "undefined" !== typeof a[l.to.toLowerCase()] &&
                  (n = a[l.to.toLowerCase()])),
              new s.default({
                ticker: n.ticker,
                name: n.name,
                walletid: n.id,
                txid: this.getTxHash(r),
                fee: this.getTxFee(r),
                feeTicker: this.wallet.feeTicker,
                direction: this.getTxDirection(e, r),
                otherSideAddress: this.getTxOtherSideAddress(e, r),
                amount: this.getTxValue(e, r, n),
                datetime: new Date(Number(i + "000")),
                memo: this.getTxMemo(r),
                nonce: this.getTxNonce(r),
                confirmations: o - r.blockNumber,
                alias: n.alias,
                status: (l && l.status) || "",
              })
            );
          }
          async getTransactions(e) {
            let {
              address: t,
              offset: a = 0,
              limit: n = this.defaultTxLimit,
            } = e;
            return [];
          }
          sendTransaction(e) {
            return new Promise((t, a) => {
              this.wallet.coreLibrary.eth
                .sendSignedTransaction(e)
                .on("transactionHash", (e) => {
                  t({ txid: e });
                })
                .catch((e) => a(e));
            });
          }
          async getGasPrice() {
            const e = await this.wallet.coreLibrary.eth.getGasPrice();
            return { node: new this.wallet.BN(e) };
          }
          getGasPriceConfig() {
            return r.default
              .get("eth-gas-price", !1, { timeout: d })
              .catch((e) => console.warn(e));
          }
          async getGasLimit() {
            const e = await this.wallet.coreLibrary.eth.getBlockNumber(),
              t = await this.wallet.coreLibrary.eth.getBlock(e);
            return t.gasLimit;
          }
          getTxHash(e) {
            return e.hash;
          }
          getTxDateTime(e) {
            return new Date(Number(e.timeStamp + "000"));
          }
          getTxNonce(e) {
            return e.nonce;
          }
          getTxConfirmations(e) {
            return Number(e.confirmations);
          }
          getTxDirection(e, t) {
            return e.toLowerCase() !== t.from.toLowerCase();
          }
          getTxOtherSideAddress(e, t) {
            let a = t.to;
            if (t.inputDecode && "transfer" === t.inputDecode.method)
              try {
                a = t.inputDecode.params._to;
              } catch (n) {
                a = "contr:" + a;
              }
            return e.toLowerCase() === t.from.toLowerCase() ? a : t.from;
          }
          getTxValue(e, t, a) {
            void 0 === a && (a = this.wallet);
            let n = t.value;
            if (t.inputDecode && "transfer" === t.inputDecode.method)
              try {
                n = t.inputDecode.params._value;
              } catch (r) {
                n = 0;
              }
            return a.toCurrencyUnit(n);
          }
          async getTokenBalanceByContractAddress(e) {
            let { address: t, contractAddress: a } = e;
            const n = new this.wallet.coreLibrary.eth.Contract(c, a);
            return n.methods.balanceOf(t).call();
          }
          getTokenBalanceOfCall(e, t) {
            let { address: a, contractAddress: n } = e;
            const r = new this.wallet.coreLibrary.eth.Contract(c, n);
            return r.methods.balanceOf(a).call.request(t);
          }
          createSendTokenContract(e, t, a, n) {
            const r = new this.wallet.coreLibrary.eth.Contract(
              this.getERC20ABI(),
              e,
              { from: t },
            );
            return r.methods.transfer(a, n).encodeABI();
          }
          decodeInput(t) {
            try {
              if (this.wallet.coreLibrary.utils.isHex(t)) {
                try {
                  return this.wallet.coreLibrary.utils.hexToString(t);
                } catch (a) {}
                const n = 4,
                  r = e.from(t.replace(/^0x/, ""), "hex"),
                  i = "0x" + r.slice(0, n).toString("hex"),
                  s = r.slice(n),
                  o = { method: null, params: {} };
                return (
                  this.getERC20ABI().forEach((e) => {
                    try {
                      const t =
                          this.wallet.coreLibrary.eth.abi.encodeFunctionSignature(
                            e,
                          ),
                        a = e.inputs ? e.inputs.map((e) => e.type) : [],
                        n = e.inputs ? e.inputs.map((e) => e.name) : [];
                      if (i === t) {
                        const t =
                          this.wallet.coreLibrary.eth.abi.decodeParameters(
                            a,
                            "0x" + s.toString("hex"),
                          );
                        o.method = e.name;
                        for (const e in t)
                          "undefined" !== typeof t[e] &&
                            (o.params[n[e]] = t[e]);
                      }
                    } catch (a) {
                      return null;
                    }
                    return null;
                  }),
                  o
                );
              }
            } catch (a) {
              throw new o.InternalError({
                type: l.INTERNAL_ERROR,
                error: a,
                instance: this,
              });
            }
            return null;
          }
          getERC20ABI() {
            return [
              {
                constant: !0,
                inputs: [],
                name: "name",
                outputs: [{ name: "", type: "string" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !1,
                inputs: [
                  { name: "_spender", type: "address" },
                  { name: "_value", type: "uint256" },
                ],
                name: "approve",
                outputs: [{ name: "success", type: "bool" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !0,
                inputs: [],
                name: "totalSupply",
                outputs: [{ name: "", type: "uint256" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !1,
                inputs: [
                  { name: "_from", type: "address" },
                  { name: "_to", type: "address" },
                  { name: "_value", type: "uint256" },
                ],
                name: "transferFrom",
                outputs: [{ name: "success", type: "bool" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !0,
                inputs: [],
                name: "decimals",
                outputs: [{ name: "", type: "uint8" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !0,
                inputs: [],
                name: "version",
                outputs: [{ name: "", type: "string" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !0,
                inputs: [{ name: "_owner", type: "address" }],
                name: "balanceOf",
                outputs: [{ name: "balance", type: "uint256" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !0,
                inputs: [],
                name: "symbol",
                outputs: [{ name: "", type: "string" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !1,
                inputs: [
                  { name: "_to", type: "address" },
                  { name: "_value", type: "uint256" },
                ],
                name: "transfer",
                outputs: [{ name: "success", type: "bool" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !1,
                inputs: [
                  { name: "_spender", type: "address" },
                  { name: "_value", type: "uint256" },
                  { name: "_extraData", type: "bytes" },
                ],
                name: "approveAndCall",
                outputs: [{ name: "success", type: "bool" }],
                payable: !1,
                type: "function",
              },
              {
                constant: !0,
                inputs: [
                  { name: "_owner", type: "address" },
                  { name: "_spender", type: "address" },
                ],
                name: "allowance",
                outputs: [{ name: "remaining", type: "uint256" }],
                payable: !1,
                type: "function",
              },
              {
                inputs: [
                  { name: "_initialAmount", type: "uint256" },
                  { name: "_tokenName", type: "string" },
                  { name: "_decimalUnits", type: "uint8" },
                  { name: "_tokenSymbol", type: "string" },
                ],
                type: "constructor",
              },
              { payable: !1, type: "fallback" },
              {
                anonymous: !1,
                inputs: [
                  { indexed: !0, name: "_from", type: "address" },
                  { indexed: !0, name: "_to", type: "address" },
                  { indexed: !1, name: "_value", type: "uint256" },
                ],
                name: "Transfer",
                type: "event",
              },
              {
                anonymous: !1,
                inputs: [
                  { indexed: !0, name: "_owner", type: "address" },
                  { indexed: !0, name: "_spender", type: "address" },
                  { indexed: !1, name: "_value", type: "uint256" },
                ],
                name: "Approval",
                type: "event",
              },
            ];
          }
          async getBalance(e) {
            return this.getInfo(e, !0);
          }
        }
        t.default = Web3Explorer;
      }).call(this, a(2).Buffer);
    },
    846: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(129)),
        i = a(27),
        s = a(19),
        o = a(4),
        l = a(67),
        c = a(384);
      function d(e, t) {
        (u(e, t), t.add(e));
      }
      function u(e, t) {
        if (t.has(e))
          throw new TypeError(
            "Cannot initialize the same private elements twice on an object",
          );
      }
      function h(e, t, a) {
        if ("function" == typeof e ? e === t : e.has(t))
          return arguments.length < 3 ? t : a;
        throw new TypeError("Private element is not present on this object");
      }
      const f = "0x0000000000000000000000000000000000000000";
      var m = new WeakSet();
      class CovalentHQExplorer extends r.default {
        constructor(e) {
          let { wallet: t, config: a } = e;
          (super({ wallet: t, config: a }), d(this, m));
        }
        modifyTokenResponse(e) {
          if (e.data && !e.data.error) return e.data.items;
          throw new s.ExplorerRequestError({
            type: i.GET_BALANCE_TYPE,
            error: new Error(JSON.stringify(e)),
            instance: this,
          });
        }
        handleRequestError(e, t) {
          var a;
          if (
            (null === (a = e.response) || void 0 === a ? void 0 : a.status) ===
            i.HTTP_STATUS_NOT_FOUND
          ) {
            switch (t.type) {
              case i.GET_TRANSACTIONS_TYPE:
                return { transactions: [] };
            }
            return null;
          }
          return super.handleRequestError(e, t);
        }
        async getUserTokenList(e) {
          try {
            const t = await this.request(
              `${this.wallet.chainId}/address/${e}/balances_v2/`,
              "get",
            );
            if (null === t || void 0 === t || !t.data) return [];
            const a = this.modifyTokenResponse(t);
            return a.map((e) => h(m, this, p).call(this, e));
          } catch (t) {
            return (console.error(t), []);
          }
        }
        getTransactionsUrl(e, t, a, n) {
          return `${this.wallet.chainId}/address/${e}/transactions_v2/`;
        }
        getTransactionsParams(e, t, a, n) {
          return (
            void 0 === t && (t = 0),
            void 0 === a && (a = this.defaultTxLimit),
            { "page-size": a, "page-number": n }
          );
        }
        modifyTransactionsResponse(e, t) {
          if (e.data && !e.data.error)
            return super.modifyTransactionsResponse(e.data.items, t);
          throw new s.ExplorerRequestError({
            type: i.GET_BALANCE_TYPE,
            error: new Error(JSON.stringify(e)),
            instance: this,
          });
        }
        getTransactionsModifiedResponse(e, t, a) {
          var n;
          void 0 === a && (a = this.wallet.ticker);
          const r = h(m, this, y).call(this, e, t);
          return {
            ticker: this.getTxTicker(r),
            name: this.getTxName(r),
            walletid: this.getTxWalletId(e, r),
            txid: e.tx_hash,
            direction: this.getTxDirection(t, e, r),
            otherSideAddress: this.getTxOtherSideAddress(t, e, r),
            amount: this.getTxValue(t, e, r),
            datetime: new Date(e.block_signed_at),
            memo: "",
            confirmations: 1,
            nonce: e.tx_offset,
            alias: this.wallet.alias,
            explorer: this.constructor.name,
            txType: this.getTxType(r),
            fee: this.wallet.toCurrencyUnit(e.fees_paid),
            feeTicker:
              null !== (n = this.wallet.feeTicker) && void 0 !== n
                ? n
                : this.wallet.ticker,
            isToken: this.getTxIsToken(r),
            isNft: this.getTxIsNft(r),
            contract: this.getTxContract(e, r),
          };
        }
        getTxTicker(e) {
          if (this.getTxIsToken(e)) {
            const { tickerSymbol: t } = h(m, this, g).call(this, e);
            return t;
          }
          return this.wallet.ticker;
        }
        getTxName(e) {
          const { typeName: t, name: a } = h(m, this, g).call(this, e);
          return t ? a : this.wallet.name;
        }
        getTxWalletId(e, t) {
          if (this.getTxIsToken(t)) {
            const a = this.getTxTicker(t),
              n = this.getTxContract(e, t);
            return (0, o.getTokenId)({
              ticker: a,
              contract: n,
              parent: this.wallet.id,
            });
          }
          return this.wallet.id;
        }
        getTxDirection(e, t, a) {
          const n = e.toLowerCase();
          if (!a) return t.to_address.toLowerCase() === n;
          const { typeName: r, to: i } = h(m, this, g).call(this, a);
          return r
            ? "string" === typeof i && i.toLowerCase() === n
            : i.toLowerCase() === n;
        }
        getTxOtherSideAddress(e, t, a) {
          const n = e.toLowerCase();
          if (!a)
            return t.to_address.toLowerCase() === n
              ? t.from_address
              : t.to_address;
          const { typeName: r, to: i, from: s } = h(m, this, g).call(this, a);
          return r
            ? "string" === typeof i && i.toLowerCase() === n
              ? s
              : i
            : i.toLowerCase() === n
              ? t.from_address
              : t.to_address;
        }
        getTxValue(e, t, a) {
          if (!a) return this.wallet.toCurrencyUnit(t.value);
          if (this.getTxIsToken(a)) {
            const { valueOrTokenId: e, decimal: t } = h(m, this, g).call(
              this,
              a,
            );
            return (0, l.toCurrency)(e, t);
          }
          return this.getTxIsNft(a) ? "NFT" : null;
        }
        getTxType(e) {
          return this.getTxIsToken(e)
            ? c.TxTypes.TRANSFER
            : this.getTxIsNft(e)
              ? c.TxTypes.TRANSFERNFT
              : c.TxTypes.TRANSACTION;
        }
        getTxIsToken(e) {
          const { typeName: t, decimal: a } = h(m, this, g).call(this, e);
          return "Transfer" === t && a > 0;
        }
        getTxIsNft(e) {
          const { typeName: t, decimal: a } = h(m, this, g).call(this, e);
          return "Transfer" === t && 0 === a;
        }
        getTxContract(e, t) {
          return this.getTxIsToken(t) || this.getTxIsNft(t)
            ? e.to_address
            : null;
        }
        async getTokensTransactions(e) {
          return { tokenTransactions: [] };
        }
      }
      function p(e) {
        return {
          name: e.contract_name,
          ticker: e.contract_ticker_symbol,
          decimal: Number(e.contract_decimals) || 0,
          contract: e.contract_address.toLowerCase(),
          parentTicker: this.wallet.ticker,
          uniqueField: e.contract_address.toLowerCase(),
          supportedStandards: e.supports_erc,
        };
      }
      function y(e, t) {
        var a;
        const n = (null !== (a = e.log_events) && void 0 !== a ? a : []).filter(
          (e) => {
            var a, n, r, i;
            const s =
                null === (a = e.decoded) ||
                void 0 === a ||
                null === (n = a.params[0]) ||
                void 0 === n
                  ? void 0
                  : n.value.toLowerCase(),
              o =
                null === (r = e.decoded) ||
                void 0 === r ||
                null === (i = r.params[1]) ||
                void 0 === i
                  ? void 0
                  : i.value.toLowerCase();
            return (
              s !== f &&
              o !== f &&
              (s === t.toLowerCase() || o === t.toLowerCase())
            );
          },
        );
        return 0 === n.length ? null : n.pop();
      }
      function g(e) {
        var t, a, n, r, i;
        if (!e) return {};
        const s = null === (t = e.decoded) || void 0 === t ? void 0 : t.params,
          o = null === (a = e.decoded) || void 0 === a ? void 0 : a.name,
          l = e.sender_name,
          c = e.sender_contract_ticker_symbol,
          d = e.sender_contract_decimals,
          u = s && (null === (n = s[0]) || void 0 === n ? void 0 : n.value),
          h = s && (null === (r = s[1]) || void 0 === r ? void 0 : r.value),
          f = s && (null === (i = s[2]) || void 0 === i ? void 0 : i.value);
        return {
          typeName: o,
          name: l,
          tickerSymbol: c,
          decimal: d,
          from: u,
          to: h,
          valueOrTokenId: f,
        };
      }
      t.default = CovalentHQExplorer;
    },
    852: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = t.COSMOS_MSG_TO_TYPE = void 0));
      t.default = {
        TRANSACTION: "Transfer",
        TRANSFER: "Transfer",
        TRANSFERNFT: "Transfer Nft",
        MINTNFT: "Mint Nft",
        STAKE: "Stake",
        DELEGATE: "Stake",
        UNSTAKE: "Unstake",
        UNDELEGATE: "Unstake",
        UNBONDING: "Unstake",
        RESTAKE: "Restake",
        REDELEGATE: "Restake",
        WITHDRAW: "Withdraw",
        WITHDRAWAL: "Withdraw",
        CLAIM: "Reward",
        REWARD: "Reward",
        VOTE: "Vote",
        FREEZE: "Freeze",
        BUY: "Buy",
        EXCHANGE: "Exchange",
      };
      t.COSMOS_MSG_TO_TYPE = {
        MsgWithdrawDelegatorReward: "reward",
        MsgDelegate: "stake",
        MsgUndelegate: "unstake",
        MsgSend: "transfer",
      };
    },
    853: function (e, t, a) {
      "use strict";
      (function (e) {
        var n = a(0);
        (Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0));
        var r = n(a(129)),
          i = a(27),
          s = a(19),
          o = a(4);
        function l(e, t) {
          (c(e, t), t.add(e));
        }
        function c(e, t) {
          if (t.has(e))
            throw new TypeError(
              "Cannot initialize the same private elements twice on an object",
            );
        }
        function d(e, t, a) {
          if ("function" == typeof e ? e === t : e.has(t))
            return arguments.length < 3 ? t : a;
          throw new TypeError("Private element is not present on this object");
        }
        const u = (t) => ("ETH" === t ? e.env.ETHERSCAN_API_KEY : null);
        var h = new WeakSet();
        class EtherscanExplorer extends r.default {
          constructor() {
            (super(...arguments), l(this, h));
          }
          modifyGeneralResponse(e) {
            if (e.data && "1" === e.data.status) return e.data;
            throw new s.ExplorerRequestError({
              type: i.GET_BALANCE_TYPE,
              error: new Error(JSON.stringify(e)),
              instance: this,
            });
          }
          getTransactionsUrl(e) {
            return "";
          }
          getTransactionsParams(e) {
            return d(h, this, f).call(this, e, "txlist");
          }
          modifyTransactionsResponse(e, t) {
            return super.modifyTransactionsResponse(
              e.result.filter((e) => {
                let { value: t } = e;
                return t > 0;
              }),
              t,
            );
          }
          async sendTransaction(e) {
            const t = await this.request("submit", null, { tx_blob: e });
            if ("tesSUCCESS" === !t.engine_result)
              throw new s.ExplorerRequestError({
                type: i.SEND_TRANSACTION_TYPE,
                error: new Error(t.engine_result),
                instance: this,
              });
            return { txid: t.tx_json.hash };
          }
          getTxHash(e) {
            return e.hash;
          }
          getTxDateTime(e) {
            return new Date(Number(e.timeStamp + "000"));
          }
          getTxConfirmations(e) {
            return Number(e.confirmations);
          }
          getTxDirection(e, t) {
            return e.toLowerCase() !== t.from.toLowerCase();
          }
          getTxOtherSideAddress(e, t) {
            return e.toLowerCase() === t.from.toLowerCase() ? t.to : t.from;
          }
          getTxValue(e, t) {
            return this.wallet.toCurrencyUnit(t.value);
          }
          getTxFeeTicker() {
            return this.wallet.feeTicker;
          }
          getTxFee(e) {
            return this.wallet.l2Name ? null : super.getTxFee(e);
          }
          async getTokensTransactions(e) {
            let { address: t, offset: a, limit: n, pageNum: r } = e;
            if (
              this.defaultRequestTimeout &&
              Date.now() - this.defaultRequestTimeout * i.ONE_MINUTE <
                this.lastGetTxsRequestTime
            )
              return [];
            this.defaultRequestTimeout &&
              Date.now() - this.defaultRequestTimeout * i.ONE_MINUTE >
                this.lastGetTxsRequestTime &&
              (this.lastGetTxsRequestTime = Date.now());
            const s = await this.request(
              this.getTransactionsUrl(),
              this.getTransactionsMethod(),
              this.getTokensTransactionsParams(t),
              i.GET_TRANSACTIONS_TYPE,
              this.getTransactionsOptions(),
            );
            return this.modifyTokenTransactionsResponse(s, t);
          }
          getTokensTransactionsParams(e) {
            return d(h, this, f).call(this, e, "tokentx");
          }
          modifyTokenTransactionsResponse(e, t) {
            const { result: a } =
                null !== e && void 0 !== e ? e : { result: [] },
              n = a.reduce((e, a, n) => {
                const r = this.getTxDirection(t, a),
                  i = a.tokenSymbol,
                  s = a.contractAddress;
                return (
                  e.push({
                    contract: s,
                    alias: this.wallet.alias,
                    explorer: this.constructor.name,
                    txid: this.getTxHash(a),
                    direction: r,
                    otherSideAddress: this.getTxOtherSideAddress(t, a),
                    amount: this.getTxValue(t, a),
                    datetime: this.getTxDateTime(a),
                    memo: "",
                    confirmations: this.getTxConfirmations(a),
                    ticker: i,
                    name: a.tokenName,
                    walletid: (0, o.getTokenId)({
                      ticker: i,
                      contract: s,
                      parent: this.wallet.id,
                    }),
                  }),
                  e
                );
              }, []);
            return { tokenTransactions: n };
          }
        }
        function f(e, t) {
          const a = {
              module: "account",
              action: t,
              address: e,
              startblock: 0,
              endblock: 99999999,
              sort: "desc",
            },
            n = u(this.wallet.id);
          return (n && (a.apikey = n), a);
        }
        t.default = EtherscanExplorer;
      }).call(this, a(18));
    },
    855: function (e, t, a) {
      "use strict";
      a.r(t);
      var n = a(333),
        r = a.n(n);
      a.d(t, "Changenow", function () {
        return r.a;
      });
      var i = a(680),
        s = a.n(i);
      a.d(t, "Simplex", function () {
        return s.a;
      });
      var o = a(682);
      a.d(t, "DataTypes", function () {
        return o;
      });
      var l = a(399);
      a.d(t, "CurrencyOperations", function () {
        return l;
      });
      var c = a(683);
      a.d(t, "CurrencyOperationsTypes", function () {
        return c;
      });
      var d = a(193);
      a.d(t, "exchangerV2", function () {
        return d["exchangerV2"];
      });
    },
    880: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(129)),
        i = a(27),
        s = a(19),
        o = n(a(80)),
        l = a(4);
      const c = "GetUserTokens";
      class BlockscoutExplorerV2 extends r.default {
        async request(e, t, a, n) {
          (void 0 === t && (t = "get"),
            void 0 === a && (a = {}),
            void 0 === n && (n = i.UNDEFINED_OPERATION_ERROR));
          const r = await super.request(e, t, a, n);
          if ("0" === r.status) {
            if ([c, i.GET_TRANSACTIONS_TYPE].includes(n)) return [];
            throw new s.ExplorerRequestError({
              type: n,
              error: r.message,
              url: `${this.config.baseUrl}${e}`,
              instance: this,
            });
          }
          return r.result ? r.result : r;
        }
        getTransactionsUrl(e) {
          return `${this.getApiPrefix()}/v2/addresses/${e}/transactions`;
        }
        async getTransactions(e) {
          let { address: t, offset: a = 0, limit: n = this.defaultTxLimit } = e;
          try {
            const e = await this.request(
                this.getTransactionsUrl(t),
                this.getTransactionsMethod(),
              ).catch(() => []),
              a = this.modifyTransactionsResponse(
                e.items
                  .filter((e) => {
                    let { raw_input: t } = e;
                    return "0x" === t;
                  })
                  .reverse(),
                t,
              );
            return a;
          } catch (r) {
            return (console.error(r), []);
          }
        }
        modifyTokenTransactionsResponse(e, t) {
          return e.map(
            (e) =>
              new o.default({
                walletid: (0, l.getTokenId)({
                  ticker: e.tokenSymbol,
                  parent: this.wallet.ticker,
                  contract: e.contractAddress,
                }),
                ticker: e.tokenSymbol,
                name: e.tokenName,
                txid: this.getTxHash(e),
                fee: this.getTxFee(e),
                feeTicker: this.wallet.parent,
                direction: this.getTxDirection(t, e),
                otherSideAddress: this.getTxOtherSideAddress(t, e),
                amount: this.getTxValue(t, e),
                datetime: this.getTxDateTime(e),
                memo: this.getTxMemo(e),
                nonce: this.getTxNonce(e),
                confirmations: this.getTxConfirmations(e),
                alias: this.wallet.alias,
              }),
          );
        }
        getTxNonce(e) {
          return e.nonce;
        }
        getTxMemo(e) {
          return e.meme;
        }
        getTxHash(e) {
          return e.hash;
        }
        getTxDateTime(e) {
          return new Date(e.timestamp);
        }
        getTxDirection(e, t) {
          return e.toLowerCase() !== t.from.hash.toLowerCase();
        }
        getTxOtherSideAddress(e, t) {
          return e.toLowerCase() === t.from.hash.toLowerCase()
            ? t.to.hash
            : t.from.hash;
        }
        getTxValue(e, t) {
          return (t.contractAddress, this.wallet.toCurrencyUnit(t.value));
        }
        getTxConfirmations(e) {
          return Number(e.confirmations);
        }
        getTxFee(e) {
          return this.wallet.toCurrencyUnit(e.fee.value);
        }
      }
      t.default = BlockscoutExplorerV2;
    },
    881: function (e) {
      e.exports = JSON.parse(
        '[{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"DecimalsUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"GasPriceUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"L1BaseFeeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"OverheadUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"ScalarUpdated","type":"event"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"gasPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"getL1Fee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"getL1GasUsed","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"l1BaseFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"overhead","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"scalar","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_decimals","type":"uint256"}],"name":"setDecimals","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_gasPrice","type":"uint256"}],"name":"setGasPrice","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_baseFee","type":"uint256"}],"name":"setL1BaseFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_overhead","type":"uint256"}],"name":"setOverhead","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_scalar","type":"uint256"}],"name":"setScalar","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]',
      );
    },
    942: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = a(412),
        i = a(35),
        s = n(a(37)),
        o = n(a(28)),
        l = T(a(8)),
        c = n(a(26)),
        d = a(436),
        u = a(437),
        h = n(a(248)),
        f = n(a(256)),
        m = a(458),
        p = n(a(257)),
        y = a(160),
        g = n(a(124)),
        w = a(382);
      function T(e, t) {
        if ("function" == typeof WeakMap)
          var a = new WeakMap(),
            n = new WeakMap();
        return (T = function (e, t) {
          if (!t && e && e.__esModule) return e;
          var r,
            i,
            s = { __proto__: null, default: e };
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return s;
          if ((r = t ? n : a)) {
            if (r.has(e)) return r.get(e);
            r.set(e, s);
          }
          for (const a in e)
            "default" !== a &&
              {}.hasOwnProperty.call(e, a) &&
              ((i =
                (r = Object.defineProperty) &&
                Object.getOwnPropertyDescriptor(e, a)) &&
              (i.get || i.set)
                ? r(s, a, i)
                : (s[a] = e[a]));
          return s;
        })(e, t);
      }
      async function v() {
        const e = 1e4;
        c.default.on(i.WALLETS.NEW_ATOMIC_ID, (e) => {
          let { atomicId: t } = e;
          o.default.setUserId(t);
        });
        try {
          const e = await l.default.get(l.ConfigKey.LogSettings, !0);
          o.default.startCloudSync(e.loggerUrl);
        } catch (t) {
          setTimeout(v, e);
        }
      }
      Promise.all([
        a.e(0),
        a.e(1),
        a.e(20),
        a.e(128),
        a.e(222),
        a.e(201),
        a.e(436),
      ]).then(a.t.bind(null, 2656, 7));
      t.default = function (e) {
        let { platform: t } = void 0 === e ? {} : e;
        (s.default.setCoreVersion(r.version),
          t &&
            (s.default.setPlatform(t.type),
            s.default.setVersion(t.version),
            s.default.setOS(t.os)),
          c.default.once(i.WALLETS.WALLET_READY, () => {}),
          (0, d.startActivityTracking)(),
          (0, u.startSettingsSync)(),
          (0, m.startSettingsSync)(),
          y.NftToken.updateIpfsGateway());
        const a = {
          txsCachePreloading: g.default.initTransactionsCache(),
          tokensPreloading: (0, w.loadTokensFromDb)(),
          logger: v(),
          chartData: h.default.fetchSettings(),
          buy: f.default.fetchSettings(),
          coinRestrictionPolicy: p.default.fetchSettings(),
        };
        return { modulesReady: a, ready: Promise.all(Object.values(a)) };
      };
    },
    982: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class ExchangeConnectionError extends Error {
        constructor() {
          super("Can't connect to ChangeNOW");
        }
      }
      t.default = ExchangeConnectionError;
    },
    983: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class ExchangeValidationError extends Error {
        constructor() {
          super(
            "Exchange Transaction validation failed, probably exchange tx has not been created properly",
          );
        }
      }
      t.default = ExchangeValidationError;
    },
    984: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(132));
      class ExplorerRequestError extends r.default {
        constructor(e) {
          (super(e),
            (this.errorData = e.errorData),
            (this.name = this.constructor.name));
        }
      }
      t.default = ExplorerRequestError;
    },
    987: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(69)),
        i = a(27),
        s = n(a(132));
      class ExternalError extends s.default {
        constructor(e) {
          (super(e),
            (0, r.default)(this, "defaultType", i.EXTERNAL_ERROR),
            (this.name = this.constructor.name));
        }
      }
      t.default = ExternalError;
    },
    988: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(132));
      const i = "WalletError";
      class WalletError extends r.default {
        constructor(e) {
          (super(e), (this.name = i));
        }
      }
      t.default = WalletError;
    },
    989: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class RequestStatusCodeError extends Error {
        constructor(e) {
          super("Request Status Code Error " + e);
        }
      }
      t.default = RequestStatusCodeError;
    },
    990: function (e, t, a) {
      "use strict";
      var n = a(0);
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      var r = n(a(132));
      const i = "InsufficientFundsError";
      class InsufficientFundsError extends r.default {
        constructor(e) {
          (super(e), (this.name = i));
        }
      }
      t.default = InsufficientFundsError;
    },
    991: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class UndeclaredAbstractMethodError extends Error {
        constructor(e, t) {
          super(
            `You should declare the '${e}' abstract method in the ${t.constructor.name} class!`,
          );
        }
      }
      t.default = UndeclaredAbstractMethodError;
    },
    992: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class AjvValidationError extends Error {
        constructor(e) {
          (super("Schema validation failed"), (this.validationErrors = e));
        }
      }
      t.default = AjvValidationError;
    },
    993: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class UnknownConfigKeyError extends Error {
        constructor(e) {
          super("Unknown config key: " + e);
        }
      }
      t.default = UnknownConfigKeyError;
    },
    994: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class DuplicatedConfigRegistrationError extends Error {
        constructor(e) {
          super("Trying to register config which is already registered: " + e);
        }
      }
      t.default = DuplicatedConfigRegistrationError;
    },
    995: function (e, t, a) {
      "use strict";
      (Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.default = void 0));
      class ExchangeConfirmsCalculationError extends Error {
        constructor(e) {
          (super("Remaining confirmations cannot be calculated", e),
            Error.captureStackTrace &&
              Error.captureStackTrace(this, this.constructor),
            (this.name = this.constructor.name));
        }
      }
      t.default = ExchangeConfirmsCalculationError;
    },
  },
]);
